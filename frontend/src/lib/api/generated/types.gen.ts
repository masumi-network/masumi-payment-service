// This file is auto-generated by @hey-api/openapi-ts

export type ApiKey = {
  /**
   * Unique identifier for the API key
   */
  id: string;
  /**
   * The API key token
   */
  token: string;
  /**
   * Permission level of the API key
   */
  permission: 'Read' | 'ReadAndPay' | 'Admin';
  /**
   * Whether the API key has usage limits
   */
  usageLimited: boolean;
  /**
   * List of Cardano networks this API key is allowed to access
   */
  networkLimit: Array<'Preprod' | 'Mainnet'>;
  /**
   * Remaining usage credits for this API key
   */
  RemainingUsageCredits: Array<{
    /**
     * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
     */
    unit: string;
    /**
     * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
     */
    amount: string;
  }>;
  /**
   * Current status of the API key
   */
  status: 'Active' | 'Revoked';
};

export type Wallet = {
  /**
   * Wallet secret (mnemonic). Only included if includeSecret is true
   */
  Secret?: {
    /**
     * Timestamp when the secret was created
     */
    createdAt: string;
    /**
     * Timestamp when the secret was last updated
     */
    updatedAt: string;
    /**
     * Decrypted 24-word mnemonic phrase for the wallet
     */
    mnemonic: string;
  };
  /**
   * Pending transaction for this wallet. Null if no transaction is pending
   */
  PendingTransaction: {
    /**
     * Timestamp when the pending transaction was created
     */
    createdAt: string;
    /**
     * Timestamp when the pending transaction was last updated
     */
    updatedAt: string;
    /**
     * Transaction hash of the pending transaction. Null if not yet submitted
     */
    hash: string | null;
    /**
     * Timestamp when the pending transaction was last checked. Null if never checked
     */
    lastCheckedAt: string | null;
  } | null;
  /**
   * Optional note about this wallet. Null if not set
   */
  note: string | null;
  /**
   * Payment key hash of the wallet
   */
  walletVkey: string;
  /**
   * Cardano address of the wallet
   */
  walletAddress: string;
  /**
   * Collection address for this wallet. Null if not set
   */
  collectionAddress: string | null;
};

export type GeneratedWalletSecret = {
  /**
   * 24-word mnemonic phrase for the newly generated wallet. IMPORTANT: Backup this mnemonic securely
   */
  walletMnemonic: string;
  /**
   * Cardano address of the newly generated wallet
   */
  walletAddress: string;
  /**
   * Payment key hash of the newly generated wallet
   */
  walletVkey: string;
};

export type Payment = {
  /**
   * Unique identifier for the payment
   */
  id: string;
  /**
   * Timestamp when the payment was created
   */
  createdAt: string;
  /**
   * Timestamp when the payment was last updated
   */
  updatedAt: string;
  /**
   * Unique blockchain identifier for the payment
   */
  blockchainIdentifier: string;
  /**
   * Identifier of the agent that is being paid
   */
  agentIdentifier: string | null;
  /**
   * Timestamp when the payment was last checked on-chain. Null if never checked
   */
  lastCheckedAt: string | null;
  /**
   * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
   */
  payByTime: string | null;
  /**
   * Unix timestamp (in milliseconds) by which the seller must submit the result
   */
  submitResultTime: string;
  /**
   * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
   */
  unlockTime: string;
  /**
   * Amount of collateral to return in lovelace. Null if no collateral
   */
  collateralReturnLovelace: string | null;
  /**
   * Unix timestamp (in milliseconds) after which external dispute resolution can occur
   */
  externalDisputeUnlockTime: string;
  /**
   * ID of the API key that created this payment
   */
  requestedById: string;
  /**
   * SHA256 hash of the result submitted by the seller (hex string)
   */
  resultHash: string | null;
  /**
   * Timestamp when the next action was last changed
   */
  nextActionLastChangedAt: string;
  /**
   * Timestamp when the on-chain state or result was last changed
   */
  onChainStateOrResultLastChangedAt: string;
  /**
   * Timestamp when the next action or on-chain state or result was last changed
   */
  nextActionOrOnChainStateOrResultLastChangedAt: string;
  /**
   * SHA256 hash of the input data for the payment (hex string)
   */
  inputHash: string | null;
  /**
   * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
   */
  totalBuyerCardanoFees: number;
  /**
   * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
   */
  totalSellerCardanoFees: number;
  /**
   * Cooldown period in milliseconds for the seller to dispute
   */
  cooldownTime: number;
  /**
   * Cooldown period in milliseconds for the buyer to dispute
   */
  cooldownTimeOtherParty: number;
  /**
   * Current state of the payment on the blockchain. Null if not yet on-chain
   */
  onChainState:
    | 'FundsLocked'
    | 'FundsOrDatumInvalid'
    | 'ResultSubmitted'
    | 'RefundRequested'
    | 'Disputed'
    | 'Withdrawn'
    | 'RefundWithdrawn'
    | 'DisputedWithdrawn';
  /**
   * Next action required for this payment
   */
  NextAction: {
    /**
     * Next action required for this payment
     */
    requestedAction:
      | 'None'
      | 'Ignore'
      | 'WaitingForManualAction'
      | 'WaitingForExternalAction'
      | 'SubmitResultRequested'
      | 'SubmitResultInitiated'
      | 'WithdrawRequested'
      | 'WithdrawInitiated'
      | 'AuthorizeRefundRequested'
      | 'AuthorizeRefundInitiated';
    /**
     * Type of error that occurred, if any
     */
    errorType: 'NetworkError' | 'Unknown';
    /**
     * Additional details about the error, if any
     */
    errorNote: string | null;
    /**
     * SHA256 hash of the result to be submitted (hex string). Null if not applicable
     */
    resultHash: string | null;
  };
  /**
   * Current active transaction for this payment. Null if no transaction in progress
   */
  CurrentTransaction: {
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Timestamp when the transaction was created
     */
    createdAt: string;
    /**
     * Timestamp when the transaction was last updated
     */
    updatedAt: string;
    fees: string | null;
    /**
     * Block height of the transaction
     */
    blockHeight: number | null;
    /**
     * Block time of the transaction
     */
    blockTime: number | null;
    /**
     * Cardano transaction hash
     */
    txHash: string | null;
    /**
     * Current status of the transaction
     */
    status:
      | 'Pending'
      | 'Confirmed'
      | 'FailedViaTimeout'
      | 'FailedViaManualReset'
      | 'RolledBack';
    /**
     * Previous on-chain state before this transaction
     */
    previousOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * New on-chain state of this transaction
     */
    newOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * Number of block confirmations for this transaction
     */
    confirmations: number | null;
  } | null;
  /**
   * Historical list of all transactions for this payment. Null or empty if includeHistory is false
   */
  TransactionHistory: Array<{
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Timestamp when the transaction was created
     */
    createdAt: string;
    /**
     * Timestamp when the transaction was last updated
     */
    updatedAt: string;
    /**
     * Cardano transaction hash
     */
    txHash: string | null;
    /**
     * Current status of the transaction
     */
    status:
      | 'Pending'
      | 'Confirmed'
      | 'FailedViaTimeout'
      | 'FailedViaManualReset'
      | 'RolledBack';
    /**
     * Fees of the transaction
     */
    fees: string | null;
    /**
     * Block height of the transaction
     */
    blockHeight: number | null;
    /**
     * Block time of the transaction
     */
    blockTime: number | null;
    /**
     * Previous on-chain state before this transaction
     */
    previousOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * New on-chain state of this transaction
     */
    newOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * Number of block confirmations for this transaction
     */
    confirmations: number | null;
  }> | null;
  RequestedFunds: Array<{
    /**
     * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
     */
    amount: string;
    /**
     * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
     */
    unit: string;
  }>;
  /**
   * List of assets and amounts withdrawn for the seller
   */
  WithdrawnForSeller: Array<{
    /**
     * Amount of the asset withdrawn (as string to handle large numbers)
     */
    amount: string;
    /**
     * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
     */
    unit: string;
  }>;
  /**
   * List of assets and amounts withdrawn for the buyer (refunds)
   */
  WithdrawnForBuyer: Array<{
    /**
     * Amount of the asset withdrawn (as string to handle large numbers)
     */
    amount: string;
    /**
     * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
     */
    unit: string;
  }>;
  /**
   * Payment source configuration for this payment
   */
  PaymentSource: {
    /**
     * Unique identifier for the payment source
     */
    id: string;
    /**
     * The Cardano network (Mainnet, Preprod, or Preview)
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * Address of the smart contract managing this payment
     */
    smartContractAddress: string;
    /**
     * Policy ID for the agent registry NFTs. Null if not applicable
     */
    policyId: string | null;
  };
  /**
   * Buyer wallet information. Null if buyer has not yet submitted payment
   */
  BuyerWallet: {
    /**
     * Unique identifier for the buyer wallet
     */
    id: string;
    /**
     * Payment key hash of the buyer wallet
     */
    walletVkey: string;
  } | null;
  /**
   * Smart contract wallet (seller wallet) managing this payment. Null if not set
   */
  SmartContractWallet: {
    /**
     * Unique identifier for the smart contract wallet
     */
    id: string;
    /**
     * Payment key hash of the smart contract wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the smart contract wallet
     */
    walletAddress: string;
  } | null;
  /**
   * Optional metadata stored with the payment for additional context. Null if not provided
   */
  metadata: string | null;
};

export type Purchase = {
  /**
   * Unique identifier for the purchase
   */
  id: string;
  /**
   * Timestamp when the purchase was created
   */
  createdAt: string;
  /**
   * Timestamp when the purchase was last updated
   */
  updatedAt: string;
  /**
   * Unique blockchain identifier for the purchase
   */
  blockchainIdentifier: string;
  /**
   * Identifier of the agent that is being purchased
   */
  agentIdentifier: string | null;
  /**
   * Timestamp when the purchase was last checked on-chain. Null if never checked
   */
  lastCheckedAt: string | null;
  /**
   * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
   */
  payByTime: string | null;
  /**
   * Unix timestamp (in milliseconds) by which the seller must submit the result
   */
  submitResultTime: string;
  /**
   * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
   */
  unlockTime: string;
  /**
   * Unix timestamp (in milliseconds) after which external dispute resolution can occur
   */
  externalDisputeUnlockTime: string;
  /**
   * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
   */
  totalBuyerCardanoFees: number;
  /**
   * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
   */
  totalSellerCardanoFees: number;
  /**
   * Timestamp when the next action or on-chain state or result was last changed
   */
  nextActionOrOnChainStateOrResultLastChangedAt: string;
  /**
   * Timestamp when the next action was last changed
   */
  nextActionLastChangedAt: string;
  /**
   * Timestamp when the on-chain state or result was last changed
   */
  onChainStateOrResultLastChangedAt: string;
  /**
   * ID of the API key that created this purchase
   */
  requestedById: string;
  /**
   * Current state of the purchase on the blockchain. Null if not yet on-chain
   */
  onChainState:
    | 'FundsLocked'
    | 'FundsOrDatumInvalid'
    | 'ResultSubmitted'
    | 'RefundRequested'
    | 'Disputed'
    | 'Withdrawn'
    | 'RefundWithdrawn'
    | 'DisputedWithdrawn';
  /**
   * Amount of collateral to return in lovelace. Null if no collateral
   */
  collateralReturnLovelace: string | null;
  /**
   * Cooldown period in milliseconds for the buyer to dispute
   */
  cooldownTime: number;
  /**
   * Cooldown period in milliseconds for the seller to dispute
   */
  cooldownTimeOtherParty: number;
  /**
   * SHA256 hash of the input data for the purchase (hex string)
   */
  inputHash: string;
  /**
   * SHA256 hash of the result submitted by the seller (hex string)
   */
  resultHash: string | null;
  /**
   * Next action required for this purchase
   */
  NextAction: {
    /**
     * Next action required for this purchase
     */
    requestedAction:
      | 'None'
      | 'Ignore'
      | 'WaitingForManualAction'
      | 'WaitingForExternalAction'
      | 'FundsLockingRequested'
      | 'FundsLockingInitiated'
      | 'SetRefundRequestedRequested'
      | 'SetRefundRequestedInitiated'
      | 'UnSetRefundRequestedRequested'
      | 'UnSetRefundRequestedInitiated'
      | 'WithdrawRefundRequested'
      | 'WithdrawRefundInitiated';
    /**
     * Type of error that occurred, if any
     */
    errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
    /**
     * Additional details about the error, if any
     */
    errorNote: string | null;
  };
  /**
   * Current active transaction for this purchase. Null if no transaction in progress
   */
  CurrentTransaction: {
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Timestamp when the transaction was created
     */
    createdAt: string;
    /**
     * Timestamp when the transaction was last updated
     */
    updatedAt: string;
    /**
     * Cardano transaction hash
     */
    txHash: string | null;
    /**
     * Current status of the transaction
     */
    status:
      | 'Pending'
      | 'Confirmed'
      | 'FailedViaTimeout'
      | 'FailedViaManualReset'
      | 'RolledBack';
    /**
     * Fees of the transaction
     */
    fees: string | null;
    /**
     * Block height of the transaction
     */
    blockHeight: number | null;
    /**
     * Block time of the transaction
     */
    blockTime: number | null;
    /**
     * Previous on-chain state before this transaction
     */
    previousOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * New on-chain state of this transaction
     */
    newOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * Number of block confirmations for this transaction
     */
    confirmations: number | null;
  } | null;
  /**
   * Historical list of all transactions for this purchase
   */
  TransactionHistory: Array<{
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Timestamp when the transaction was created
     */
    createdAt: string;
    /**
     * Timestamp when the transaction was last updated
     */
    updatedAt: string;
    /**
     * Cardano transaction hash
     */
    txHash: string | null;
    /**
     * Current status of the transaction
     */
    status:
      | 'Pending'
      | 'Confirmed'
      | 'FailedViaTimeout'
      | 'FailedViaManualReset'
      | 'RolledBack';
    /**
     * Fees of the transaction
     */
    fees: string | null;
    /**
     * Block height of the transaction
     */
    blockHeight: number | null;
    /**
     * Block time of the transaction
     */
    blockTime: number | null;
    /**
     * Previous on-chain state before this transaction
     */
    previousOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * New on-chain state of this transaction
     */
    newOnChainState:
      | 'FundsLocked'
      | 'FundsOrDatumInvalid'
      | 'ResultSubmitted'
      | 'RefundRequested'
      | 'Disputed'
      | 'Withdrawn'
      | 'RefundWithdrawn'
      | 'DisputedWithdrawn';
    /**
     * Number of block confirmations for this transaction
     */
    confirmations: number | null;
  }>;
  PaidFunds: Array<{
    amount: string;
    unit: string;
  }>;
  WithdrawnForSeller: Array<{
    amount: string;
    unit: string;
  }>;
  WithdrawnForBuyer: Array<{
    amount: string;
    unit: string;
  }>;
  PaymentSource: {
    id: string;
    network: 'Preprod' | 'Mainnet';
    smartContractAddress: string;
    policyId: string | null;
  };
  /**
   * Seller wallet information. Null if not set
   */
  SellerWallet: {
    /**
     * Unique identifier for the seller wallet
     */
    id: string;
    /**
     * Payment key hash of the seller wallet
     */
    walletVkey: string;
  } | null;
  /**
   * Smart contract wallet (seller wallet) managing this purchase. Null if not set
   */
  SmartContractWallet: {
    /**
     * Unique identifier for the smart contract wallet
     */
    id: string;
    /**
     * Payment key hash of the smart contract wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the smart contract wallet
     */
    walletAddress: string;
  } | null;
  /**
   * Optional metadata stored with the purchase for additional context. Null if not provided
   */
  metadata: string | null;
};

export type AgentMetadata = {
  /**
   * Policy ID of the agent registry NFT
   */
  policyId: string;
  /**
   * Asset name of the agent registry NFT
   */
  assetName: string;
  /**
   * Full agent identifier (policy ID + asset name)
   */
  agentIdentifier: string;
  /**
   * On-chain metadata for the agent
   */
  Metadata: {
    /**
     * Name of the agent
     */
    name: string;
    /**
     * Description of the agent. Null if not provided
     */
    description?: string | null;
    /**
     * Base URL of the agent API for interactions
     */
    apiBaseUrl: string;
    /**
     * List of example outputs from the agent
     */
    ExampleOutputs: Array<{
      /**
       * Name of the example output
       */
      name: string;
      /**
       * MIME type of the example output (e.g., image/png, text/plain)
       */
      mimeType: string;
      /**
       * URL to the example output
       */
      url: string;
    }>;
    /**
     * List of tags categorizing the agent
     */
    Tags: Array<string>;
    /**
     * Information about the AI model and version used by the agent. Null if not provided
     */
    Capability?: {
      /**
       * Name of the AI model/capability. Null if not provided
       */
      name?: string | null;
      /**
       * Version of the AI model/capability. Null if not provided
       */
      version?: string | null;
    } | null;
    /**
     * Author information for the agent
     */
    Author: {
      /**
       * Name of the agent author
       */
      name: string;
      /**
       * Contact email of the author. Null if not provided
       */
      contactEmail?: string | null;
      /**
       * Other contact information for the author. Null if not provided
       */
      contactOther?: string | null;
      /**
       * Organization of the author. Null if not provided
       */
      organization?: string | null;
    };
    /**
     * Legal information about the agent. Null if not provided
     */
    Legal?: {
      /**
       * URL to the privacy policy. Null if not provided
       */
      privacyPolicy?: string | null;
      /**
       * URL to the terms of service. Null if not provided
       */
      terms?: string | null;
      /**
       * Other legal information. Null if not provided
       */
      other?: string | null;
    } | null;
    /**
     * Pricing information for the agent
     */
    AgentPricing:
      | {
          /**
           * Pricing type for the agent (Fixed or Free)
           */
          pricingType: 'Fixed';
          /**
           * List of assets and amounts for fixed pricing
           */
          Pricing: Array<{
            /**
             * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
             */
            amount: string;
            /**
             * Asset policy id + asset name concatenated. Uses an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
             */
            unit: string;
          }>;
        }
      | {
          /**
           * Pricing type for the agent (Fixed or Free)
           */
          pricingType: 'Free';
        };
    /**
     * URL to the agent image/logo
     */
    image: string;
    /**
     * Version of the metadata schema (currently only version 1 is supported)
     */
    metadataVersion: number;
  };
};

export type RegistryEntry = {
  /**
   * Error message if registration failed. Null if no error
   */
  error: string | null;
  /**
   * Unique identifier for the registry request
   */
  id: string;
  /**
   * Name of the agent
   */
  name: string;
  /**
   * Description of the agent. Null if not provided
   */
  description: string | null;
  /**
   * Base URL of the agent API for interactions
   */
  apiBaseUrl: string;
  /**
   * Information about the AI model and version used by the agent
   */
  Capability: {
    /**
     * Name of the AI model/capability. Null if not provided
     */
    name: string | null;
    /**
     * Version of the AI model/capability. Null if not provided
     */
    version: string | null;
  };
  /**
   * Author information for the agent
   */
  Author: {
    /**
     * Name of the agent author
     */
    name: string;
    /**
     * Contact email of the author. Null if not provided
     */
    contactEmail: string | null;
    /**
     * Other contact information for the author. Null if not provided
     */
    contactOther: string | null;
    /**
     * Organization of the author. Null if not provided
     */
    organization: string | null;
  };
  /**
   * Legal information about the agent
   */
  Legal: {
    /**
     * URL to the privacy policy. Null if not provided
     */
    privacyPolicy: string | null;
    /**
     * URL to the terms of service. Null if not provided
     */
    terms: string | null;
    /**
     * Other legal information. Null if not provided
     */
    other: string | null;
  };
  /**
   * Current state of the registration process
   */
  state:
    | 'RegistrationRequested'
    | 'RegistrationInitiated'
    | 'RegistrationConfirmed'
    | 'RegistrationFailed'
    | 'DeregistrationRequested'
    | 'DeregistrationInitiated'
    | 'DeregistrationConfirmed'
    | 'DeregistrationFailed';
  /**
   * List of tags categorizing the agent
   */
  Tags: Array<string>;
  /**
   * Timestamp when the registry request was created
   */
  createdAt: string;
  /**
   * Timestamp when the registry request was last updated
   */
  updatedAt: string;
  /**
   * Timestamp when the registry was last checked. Null if never checked
   */
  lastCheckedAt: string | null;
  /**
   * List of example outputs from the agent
   */
  ExampleOutputs: Array<{
    /**
     * Name of the example output
     */
    name: string;
    /**
     * URL to the example output
     */
    url: string;
    /**
     * MIME type of the example output (e.g., image/png, text/plain)
     */
    mimeType: string;
  }>;
  /**
   * Full agent identifier (policy ID + asset name). Null if not yet minted
   */
  agentIdentifier: string | null;
  /**
   * Pricing information for the agent
   */
  AgentPricing:
    | {
        /**
         * Pricing type for the agent
         */
        pricingType: 'Fixed';
        /**
         * List of assets and amounts for fixed pricing
         */
        Pricing: Array<{
          /**
           * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
           */
          amount: string;
          /**
           * Asset policy id + asset name concatenated. Uses an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
           */
          unit: string;
        }>;
      }
    | {
        /**
         * Pricing type for the agent
         */
        pricingType: 'Free';
      };
  /**
   * Smart contract wallet managing this agent registration
   */
  SmartContractWallet: {
    /**
     * Payment key hash of the smart contract wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the smart contract wallet
     */
    walletAddress: string;
  };
  CurrentTransaction: {
    /**
     * Cardano transaction hash
     */
    txHash: string | null;
    /**
     * Current status of the transaction
     */
    status:
      | 'Pending'
      | 'Confirmed'
      | 'FailedViaTimeout'
      | 'FailedViaManualReset'
      | 'RolledBack';
    /**
     * Number of block confirmations for this transaction. Null if not yet confirmed
     */
    confirmations: number | null;
    /**
     * Fees of the transaction
     */
    fees: string | null;
    /**
     * Block height of the transaction
     */
    blockHeight: number | null;
    /**
     * Block time of the transaction
     */
    blockTime: number | null;
  } | null;
};

export type PaymentSource = {
  /**
   * Unique identifier for the payment source
   */
  id: string;
  /**
   * Timestamp when the payment source was created
   */
  createdAt: string;
  /**
   * Timestamp when the payment source was last updated
   */
  updatedAt: string;
  /**
   * The Cardano network (Mainnet, Preprod, or Preview)
   */
  network: 'Preprod' | 'Mainnet';
  /**
   * Policy ID for the agent registry NFTs. Null if not applicable
   */
  policyId: string | null;
  /**
   * Address of the smart contract for this payment source
   */
  smartContractAddress: string;
  /**
   * Last agent identifier checked during registry sync. Null if not synced yet
   */
  lastIdentifierChecked: string | null;
  /**
   * Timestamp when the registry was last synced. Null if never synced
   */
  lastCheckedAt: string | null;
  /**
   * List of admin wallets for dispute resolution
   */
  AdminWallets: Array<{
    /**
     * Cardano address of the admin wallet
     */
    walletAddress: string;
    /**
     * Order/index of this admin wallet
     */
    order: number;
  }>;
  /**
   * List of wallets used for purchasing (buyer side)
   */
  PurchasingWallets: Array<{
    /**
     * Unique identifier for the purchasing wallet
     */
    id: string;
    /**
     * Payment key hash of the purchasing wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the purchasing wallet
     */
    walletAddress: string;
    /**
     * Optional collection address for this wallet. Null if not set
     */
    collectionAddress: string | null;
    /**
     * Optional note about this wallet. Null if not set
     */
    note: string | null;
  }>;
  /**
   * List of wallets used for selling (seller side)
   */
  SellingWallets: Array<{
    /**
     * Unique identifier for the selling wallet
     */
    id: string;
    /**
     * Payment key hash of the selling wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the selling wallet
     */
    walletAddress: string;
    /**
     * Optional collection address for this wallet. Null if not set
     */
    collectionAddress: string | null;
    /**
     * Optional note about this wallet. Null if not set
     */
    note: string | null;
  }>;
  /**
   * Wallet that receives network fees from transactions
   */
  FeeReceiverNetworkWallet: {
    /**
     * Cardano address that receives network fees
     */
    walletAddress: string;
  };
  /**
   * Fee rate in permille
   */
  feeRatePermille: number;
};

export type PaymentSourceExtended = {
  /**
   * Unique identifier for the payment source
   */
  id: string;
  /**
   * Timestamp when the payment source was created
   */
  createdAt: string;
  /**
   * Timestamp when the payment source was last updated
   */
  updatedAt: string;
  /**
   * The Cardano network
   */
  network: 'Preprod' | 'Mainnet';
  /**
   * Policy ID for the agent registry NFTs. Null if not applicable
   */
  policyId: string | null;
  /**
   * Address of the smart contract for this payment source
   */
  smartContractAddress: string;
  /**
   * RPC provider configuration for blockchain interactions
   */
  PaymentSourceConfig: {
    /**
     * The RPC provider API key (e.g., Blockfrost project ID)
     */
    rpcProviderApiKey: string;
    /**
     * The RPC provider type (e.g., Blockfrost)
     */
    rpcProvider: 'Blockfrost';
  };
  /**
   * Last agent identifier checked during registry sync. Null if not synced yet
   */
  lastIdentifierChecked: string | null;
  /**
   * Whether a registry sync is currently in progress
   */
  syncInProgress: boolean;
  /**
   * Timestamp when the registry was last synced. Null if never synced
   */
  lastCheckedAt: string | null;
  /**
   * List of admin wallets for dispute resolution (exactly 3 required)
   */
  AdminWallets: Array<{
    /**
     * Cardano address of the admin wallet
     */
    walletAddress: string;
    /**
     * Order/index of this admin wallet (0-2)
     */
    order: number;
  }>;
  /**
   * List of wallets used for purchasing (buyer side)
   */
  PurchasingWallets: Array<{
    /**
     * Unique identifier for the purchasing wallet
     */
    id: string;
    /**
     * Payment key hash of the purchasing wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the purchasing wallet
     */
    walletAddress: string;
    /**
     * Optional collection address for this wallet. Null if not set
     */
    collectionAddress: string | null;
    /**
     * Optional note about this wallet. Null if not set
     */
    note: string | null;
  }>;
  /**
   * List of wallets used for selling (seller side)
   */
  SellingWallets: Array<{
    /**
     * Unique identifier for the selling wallet
     */
    id: string;
    /**
     * Payment key hash of the selling wallet
     */
    walletVkey: string;
    /**
     * Cardano address of the selling wallet
     */
    walletAddress: string;
    /**
     * Optional collection address for this wallet. Null if not set
     */
    collectionAddress: string | null;
    /**
     * Optional note about this wallet. Null if not set
     */
    note: string | null;
  }>;
  /**
   * Wallet that receives network fees from transactions
   */
  FeeReceiverNetworkWallet: {
    /**
     * Cardano address that receives network fees
     */
    walletAddress: string;
  };
  /**
   * Fee rate in permille (per thousand). Example: 50 = 5%
   */
  feeRatePermille: number;
};

export type Utxo = {
  /**
   * Transaction hash containing this UTXO
   */
  txHash: string;
  /**
   * Cardano address holding this UTXO
   */
  address: string;
  /**
   * List of assets and amounts in this UTXO
   */
  Amounts: Array<{
    /**
     * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
     */
    unit: string;
    /**
     * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
     */
    quantity: number | null;
  }>;
  /**
   * Hash of the datum attached to this UTXO. Null if no datum
   */
  dataHash: string | null;
  /**
   * Inline datum data in CBOR hex format. Null if no inline datum
   */
  inlineDatum: string | null;
  /**
   * Hash of the reference script attached to this UTXO. Null if no reference script
   */
  referenceScriptHash: string | null;
  /**
   * Output index of this UTXO in the transaction
   */
  outputIndex: number | null;
  /**
   * Block hash where this UTXO was created
   */
  block: string;
};

export type RpcProviderKey = {
  /**
   * Unique identifier for the RPC provider key
   */
  id: string;
  /**
   * The RPC provider API key
   */
  rpcProviderApiKey: string;
  /**
   * The RPC provider type
   */
  rpcProvider: 'Blockfrost';
  /**
   * Timestamp when the RPC provider key was created
   */
  createdAt: string;
  /**
   * Timestamp when the RPC provider key was last updated
   */
  updatedAt: string;
  /**
   * The Cardano network this RPC provider key is for
   */
  network: 'Preprod' | 'Mainnet';
};

export type GetHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/health/';
};

export type GetHealthResponses = {
  /**
   * Object with status ok, if the server is running
   */
  200: {
    /**
     * Health status of the service. Returns "ok" when the service is running
     */
    status: string;
  };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetApiKeyStatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api-key-status/';
};

export type GetApiKeyStatusResponses = {
  /**
   * API key status
   */
  200: {
    status: string;
    data: ApiKey;
  };
};

export type GetApiKeyStatusResponse =
  GetApiKeyStatusResponses[keyof GetApiKeyStatusResponses];

export type GetWalletData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The type of wallet to query
     */
    walletType: 'Selling' | 'Purchasing';
    /**
     * The id of the wallet to query
     */
    id: string;
    /**
     * Whether to include the decrypted secret in the response
     */
    includeSecret?: string;
  };
  url: '/wallet/';
};

export type GetWalletResponses = {
  /**
   * Wallet status
   */
  200: {
    status: string;
    data: Wallet;
  };
};

export type GetWalletResponse = GetWalletResponses[keyof GetWalletResponses];

export type PatchWalletData = {
  body?: {
    /**
     * The id of the wallet to update
     */
    id: string;
    /**
     * The new collection address to set for this wallet. Pass null to clear.
     */
    newCollectionAddress: string | null;
  };
  path?: never;
  query?: never;
  url: '/wallet/';
};

export type PatchWalletResponses = {
  /**
   * Wallet updated
   */
  200: Wallet & unknown;
};

export type PatchWalletResponse =
  PatchWalletResponses[keyof PatchWalletResponses];

export type PostWalletData = {
  body?: {
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/wallet/';
};

export type PostWalletResponses = {
  /**
   * Wallet created
   */
  200: GeneratedWalletSecret;
};

export type PostWalletResponse = PostWalletResponses[keyof PostWalletResponses];

export type PostRevealDataData = {
  body?: {
    /**
     * Cryptographic signature from the admin wallet
     */
    signature: string;
    /**
     * Public key used to create the signature
     */
    key: string;
    /**
     * Cardano address of the admin wallet signing the request
     */
    walletAddress: string;
    /**
     * Unix timestamp (in milliseconds) until which this signature is valid
     */
    validUntil: number;
    /**
     * The blockchain identifier, for which the data should be revealed
     */
    blockchainIdentifier: string;
    /**
     * The action to perform
     */
    action: 'reveal_data';
  };
  path?: never;
  query?: never;
  url: '/reveal-data/';
};

export type PostRevealDataResponses = {
  /**
   * Revealed data
   */
  200: {
    /**
     * Whether the signature is valid and the data can be revealed
     */
    isValid: boolean;
  };
};

export type PostRevealDataResponse =
  PostRevealDataResponses[keyof PostRevealDataResponses];

export type DeleteApiKeyData = {
  body?: {
    /**
     * The id of the API key to be (soft) deleted.
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type DeleteApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type DeleteApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: ApiKey;
    status: string;
  };
};

export type DeleteApiKeyResponse =
  DeleteApiKeyResponses[keyof DeleteApiKeyResponses];

export type GetApiKeyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of API keys to return
     */
    limit?: number;
    /**
     * Used to paginate through the API keys
     */
    cursorToken?: string;
  };
  url: '/api-key/';
};

export type GetApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetApiKeyResponses = {
  /**
   * Api key status
   */
  200: {
    status: string;
    data: {
      /**
       * List of API keys
       */
      ApiKeys: Array<ApiKey>;
    };
  };
};

export type GetApiKeyResponse = GetApiKeyResponses[keyof GetApiKeyResponses];

export type PatchApiKeyData = {
  body?: {
    /**
     * The id of the API key to update. Provide either id or apiKey
     */
    id: string;
    /**
     * To change the api key token
     */
    token?: string;
    /**
     * The amount of credits to add or remove from the API key. Only relevant if usageLimited is true.
     */
    UsageCreditsToAddOrRemove?: Array<{
      /**
       * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
       */
      unit: string;
      /**
       * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
       */
      amount: string;
    }>;
    /**
     * Whether the API key is usage limited
     */
    usageLimited?: boolean;
    /**
     * The status of the API key
     */
    status?: 'Active' | 'Revoked';
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PatchApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PatchApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: ApiKey;
    status: string;
  };
};

export type PatchApiKeyResponse =
  PatchApiKeyResponses[keyof PatchApiKeyResponses];

export type PostApiKeyData = {
  body?: {
    /**
     * Whether the API key is usage limited. Meaning only allowed to use the specified credits or can freely spend
     */
    usageLimited?: string;
    /**
     * The credits allowed to be used by the API key. Only relevant if usageLimited is true.
     */
    UsageCredits: Array<{
      /**
       * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
       */
      unit: string;
      /**
       * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
       */
      amount: string;
    }>;
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
    /**
     * The permission of the API key
     */
    permission?: 'Read' | 'ReadAndPay' | 'Admin';
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PostApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: ApiKey;
    status: string;
  };
};

export type PostApiKeyResponse = PostApiKeyResponses[keyof PostApiKeyResponses];

export type GetPaymentData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Used to paginate through the payments. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/';
};

export type GetPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentResponses = {
  /**
   * Payment status
   */
  200: {
    status: string;
    data: {
      Payments: Array<Payment>;
    };
  };
};

export type GetPaymentResponse = GetPaymentResponses[keyof GetPaymentResponses];

export type PostPaymentData = {
  body?: {
    /**
     * The hash of the input data of the payment, should be sha256 hash of the input data, therefore needs to be in hex string format
     */
    inputHash: string;
    /**
     * The network the payment will be received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The identifier of the agent that will be paid
     */
    agentIdentifier: string;
    /**
     * The amounts of the payment, should be null for fixed amount
     */
    RequestedFunds?: Array<{
      /**
       * Amount of the asset in smallest unit (e.g., lovelace for ADA)
       */
      amount: string;
      /**
       * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
       */
      unit: string;
    }>;
    /**
     * The time after which the payment has to be submitted to the smart contract
     */
    payByTime?: Date;
    /**
     * The time after which the payment has to be submitted to the smart contract
     */
    submitResultTime?: Date;
    /**
     * The time after which the payment will be unlocked
     */
    unlockTime?: Date;
    /**
     * The time after which the payment will be unlocked for external dispute
     */
    externalDisputeUnlockTime?: Date;
    /**
     * Metadata to be stored with the payment request
     */
    metadata?: string;
    /**
     * The a unique nonce from the purchaser. Required to be in hex format
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/payment/';
};

export type PostPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentResponses = {
  /**
   * Payment request created
   */
  200: {
    data: {
      /**
       * Unique identifier for the payment
       */
      id: string;
      /**
       * Timestamp when the payment was created
       */
      createdAt: string;
      /**
       * Timestamp when the payment was last updated
       */
      updatedAt: string;
      /**
       * Unique blockchain identifier for the payment
       */
      blockchainIdentifier: string;
      /**
       * Identifier of the agent that is being paid
       */
      agentIdentifier: string | null;
      /**
       * Timestamp when the payment was last checked on-chain. Null if never checked
       */
      lastCheckedAt: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
       */
      payByTime: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the seller must submit the result
       */
      submitResultTime: string;
      /**
       * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
       */
      unlockTime: string;
      /**
       * Amount of collateral to return in lovelace. Null if no collateral
       */
      collateralReturnLovelace: string | null;
      /**
       * Unix timestamp (in milliseconds) after which external dispute resolution can occur
       */
      externalDisputeUnlockTime: string;
      /**
       * ID of the API key that created this payment
       */
      requestedById: string;
      /**
       * SHA256 hash of the result submitted by the seller (hex string)
       */
      resultHash: string | null;
      /**
       * Timestamp when the next action was last changed
       */
      nextActionLastChangedAt: string;
      /**
       * Timestamp when the on-chain state or result was last changed
       */
      onChainStateOrResultLastChangedAt: string;
      /**
       * Timestamp when the next action or on-chain state or result was last changed
       */
      nextActionOrOnChainStateOrResultLastChangedAt: string;
      /**
       * SHA256 hash of the input data for the payment (hex string)
       */
      inputHash: string | null;
      /**
       * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
       */
      totalBuyerCardanoFees: number;
      /**
       * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
       */
      totalSellerCardanoFees: number;
      /**
       * Cooldown period in milliseconds for the seller to dispute
       */
      cooldownTime: number;
      /**
       * Cooldown period in milliseconds for the buyer to dispute
       */
      cooldownTimeOtherParty: number;
      /**
       * Current state of the payment on the blockchain. Null if not yet on-chain
       */
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      /**
       * Next action required for this payment
       */
      NextAction: {
        /**
         * Next action required for this payment
         */
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        /**
         * Type of error that occurred, if any
         */
        errorType: 'NetworkError' | 'Unknown';
        /**
         * Additional details about the error, if any
         */
        errorNote: string | null;
        /**
         * SHA256 hash of the result to be submitted (hex string). Null if not applicable
         */
        resultHash: string | null;
      };
      /**
       * Current active transaction for this payment. Null if no transaction in progress
       */
      CurrentTransaction: {
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Timestamp when the transaction was created
         */
        createdAt: string;
        /**
         * Timestamp when the transaction was last updated
         */
        updatedAt: string;
        fees: string | null;
        /**
         * Block height of the transaction
         */
        blockHeight: number | null;
        /**
         * Block time of the transaction
         */
        blockTime: number | null;
        /**
         * Cardano transaction hash
         */
        txHash: string | null;
        /**
         * Current status of the transaction
         */
        status:
          | 'Pending'
          | 'Confirmed'
          | 'FailedViaTimeout'
          | 'FailedViaManualReset'
          | 'RolledBack';
        /**
         * Previous on-chain state before this transaction
         */
        previousOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * New on-chain state of this transaction
         */
        newOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * Number of block confirmations for this transaction
         */
        confirmations: number | null;
      } | null;
      RequestedFunds: Array<{
        /**
         * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the seller
       */
      WithdrawnForSeller: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the buyer (refunds)
       */
      WithdrawnForBuyer: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * Payment source configuration for this payment
       */
      PaymentSource: {
        /**
         * Unique identifier for the payment source
         */
        id: string;
        /**
         * The Cardano network (Mainnet, Preprod, or Preview)
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * Address of the smart contract managing this payment
         */
        smartContractAddress: string;
        /**
         * Policy ID for the agent registry NFTs. Null if not applicable
         */
        policyId: string | null;
      };
      /**
       * Buyer wallet information. Null if buyer has not yet submitted payment
       */
      BuyerWallet: {
        /**
         * Unique identifier for the buyer wallet
         */
        id: string;
        /**
         * Payment key hash of the buyer wallet
         */
        walletVkey: string;
      } | null;
      /**
       * Smart contract wallet (seller wallet) managing this payment. Null if not set
       */
      SmartContractWallet: {
        /**
         * Unique identifier for the smart contract wallet
         */
        id: string;
        /**
         * Payment key hash of the smart contract wallet
         */
        walletVkey: string;
        /**
         * Cardano address of the smart contract wallet
         */
        walletAddress: string;
      } | null;
      /**
       * Optional metadata stored with the payment for additional context. Null if not provided
       */
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentResponse =
  PostPaymentResponses[keyof PostPaymentResponses];

export type GetPaymentDiffData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Pagination cursor (payment id). Used as tie-breaker when lastUpdate equals a payment change timestamp
     */
    cursorId?: string;
    /**
     * Return payments whose selected status timestamp changed after this ISO timestamp
     */
    lastUpdate?: Date;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/diff';
};

export type GetPaymentDiffErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentDiffResponses = {
  /**
   * Payment diff
   */
  200: {
    status: string;
    data: {
      Payments: Array<Payment>;
    };
  };
};

export type GetPaymentDiffResponse =
  GetPaymentDiffResponses[keyof GetPaymentDiffResponses];

export type GetPaymentDiffNextActionData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Pagination cursor (payment id). Used as tie-breaker when lastUpdate equals a payment change timestamp
     */
    cursorId?: string;
    /**
     * Return payments whose selected status timestamp changed after this ISO timestamp
     */
    lastUpdate?: Date;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/diff/next-action';
};

export type GetPaymentDiffNextActionErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentDiffNextActionResponses = {
  /**
   * Payment diff
   */
  200: {
    status: string;
    data: {
      Payments: Array<Payment>;
    };
  };
};

export type GetPaymentDiffNextActionResponse =
  GetPaymentDiffNextActionResponses[keyof GetPaymentDiffNextActionResponses];

export type GetPaymentDiffOnchainStateOrResultData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Pagination cursor (payment id). Used as tie-breaker when lastUpdate equals a payment change timestamp
     */
    cursorId?: string;
    /**
     * Return payments whose selected status timestamp changed after this ISO timestamp
     */
    lastUpdate?: Date;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/diff/onchain-state-or-result';
};

export type GetPaymentDiffOnchainStateOrResultErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentDiffOnchainStateOrResultResponses = {
  /**
   * Payment diff
   */
  200: {
    status: string;
    data: {
      Payments: Array<Payment>;
    };
  };
};

export type GetPaymentDiffOnchainStateOrResultResponse =
  GetPaymentDiffOnchainStateOrResultResponses[keyof GetPaymentDiffOnchainStateOrResultResponses];

export type PostPaymentSubmitResultData = {
  body?: {
    /**
     * The network the payment was received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The hash of the AI agent result to be submitted, should be sha256 hash of the result, therefore needs to be in hex string format
     */
    submitResultHash: string;
    /**
     * The identifier of the payment
     */
    blockchainIdentifier: string;
  };
  path?: never;
  query?: never;
  url: '/payment/submit-result';
};

export type PostPaymentSubmitResultErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentSubmitResultResponses = {
  /**
   * Payment updated
   */
  200: {
    data: {
      /**
       * Unique identifier for the payment
       */
      id: string;
      /**
       * Timestamp when the payment was created
       */
      createdAt: string;
      /**
       * Timestamp when the payment was last updated
       */
      updatedAt: string;
      /**
       * Unique blockchain identifier for the payment
       */
      blockchainIdentifier: string;
      /**
       * Identifier of the agent that is being paid
       */
      agentIdentifier: string | null;
      /**
       * Timestamp when the payment was last checked on-chain. Null if never checked
       */
      lastCheckedAt: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
       */
      payByTime: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the seller must submit the result
       */
      submitResultTime: string;
      /**
       * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
       */
      unlockTime: string;
      /**
       * Amount of collateral to return in lovelace. Null if no collateral
       */
      collateralReturnLovelace: string | null;
      /**
       * Unix timestamp (in milliseconds) after which external dispute resolution can occur
       */
      externalDisputeUnlockTime: string;
      /**
       * ID of the API key that created this payment
       */
      requestedById: string;
      /**
       * SHA256 hash of the result submitted by the seller (hex string)
       */
      resultHash: string | null;
      /**
       * Timestamp when the next action was last changed
       */
      nextActionLastChangedAt: string;
      /**
       * Timestamp when the on-chain state or result was last changed
       */
      onChainStateOrResultLastChangedAt: string;
      /**
       * Timestamp when the next action or on-chain state or result was last changed
       */
      nextActionOrOnChainStateOrResultLastChangedAt: string;
      /**
       * SHA256 hash of the input data for the payment (hex string)
       */
      inputHash: string | null;
      /**
       * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
       */
      totalBuyerCardanoFees: number;
      /**
       * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
       */
      totalSellerCardanoFees: number;
      /**
       * Cooldown period in milliseconds for the seller to dispute
       */
      cooldownTime: number;
      /**
       * Cooldown period in milliseconds for the buyer to dispute
       */
      cooldownTimeOtherParty: number;
      /**
       * Current state of the payment on the blockchain. Null if not yet on-chain
       */
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      /**
       * Next action required for this payment
       */
      NextAction: {
        /**
         * Next action required for this payment
         */
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        /**
         * Type of error that occurred, if any
         */
        errorType: 'NetworkError' | 'Unknown';
        /**
         * Additional details about the error, if any
         */
        errorNote: string | null;
        /**
         * SHA256 hash of the result to be submitted (hex string). Null if not applicable
         */
        resultHash: string | null;
      };
      /**
       * Current active transaction for this payment. Null if no transaction in progress
       */
      CurrentTransaction: {
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Timestamp when the transaction was created
         */
        createdAt: string;
        /**
         * Timestamp when the transaction was last updated
         */
        updatedAt: string;
        fees: string | null;
        /**
         * Block height of the transaction
         */
        blockHeight: number | null;
        /**
         * Block time of the transaction
         */
        blockTime: number | null;
        /**
         * Cardano transaction hash
         */
        txHash: string | null;
        /**
         * Current status of the transaction
         */
        status:
          | 'Pending'
          | 'Confirmed'
          | 'FailedViaTimeout'
          | 'FailedViaManualReset'
          | 'RolledBack';
        /**
         * Previous on-chain state before this transaction
         */
        previousOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * New on-chain state of this transaction
         */
        newOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * Number of block confirmations for this transaction
         */
        confirmations: number | null;
      } | null;
      RequestedFunds: Array<{
        /**
         * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the seller
       */
      WithdrawnForSeller: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the buyer (refunds)
       */
      WithdrawnForBuyer: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * Payment source configuration for this payment
       */
      PaymentSource: {
        /**
         * Unique identifier for the payment source
         */
        id: string;
        /**
         * The Cardano network (Mainnet, Preprod, or Preview)
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * Address of the smart contract managing this payment
         */
        smartContractAddress: string;
        /**
         * Policy ID for the agent registry NFTs. Null if not applicable
         */
        policyId: string | null;
      };
      /**
       * Buyer wallet information. Null if buyer has not yet submitted payment
       */
      BuyerWallet: {
        /**
         * Unique identifier for the buyer wallet
         */
        id: string;
        /**
         * Payment key hash of the buyer wallet
         */
        walletVkey: string;
      } | null;
      /**
       * Smart contract wallet (seller wallet) managing this payment. Null if not set
       */
      SmartContractWallet: {
        /**
         * Unique identifier for the smart contract wallet
         */
        id: string;
        /**
         * Payment key hash of the smart contract wallet
         */
        walletVkey: string;
        /**
         * Cardano address of the smart contract wallet
         */
        walletAddress: string;
      } | null;
      /**
       * Optional metadata stored with the payment for additional context. Null if not provided
       */
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentSubmitResultResponse =
  PostPaymentSubmitResultResponses[keyof PostPaymentSubmitResultResponses];

export type PostPaymentAuthorizeRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/payment/authorize-refund';
};

export type PostPaymentAuthorizeRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentAuthorizeRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      /**
       * Unique identifier for the payment
       */
      id: string;
      /**
       * Timestamp when the payment was created
       */
      createdAt: string;
      /**
       * Timestamp when the payment was last updated
       */
      updatedAt: string;
      /**
       * Unique blockchain identifier for the payment
       */
      blockchainIdentifier: string;
      /**
       * Identifier of the agent that is being paid
       */
      agentIdentifier: string | null;
      /**
       * Timestamp when the payment was last checked on-chain. Null if never checked
       */
      lastCheckedAt: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
       */
      payByTime: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the seller must submit the result
       */
      submitResultTime: string;
      /**
       * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
       */
      unlockTime: string;
      /**
       * Amount of collateral to return in lovelace. Null if no collateral
       */
      collateralReturnLovelace: string | null;
      /**
       * Unix timestamp (in milliseconds) after which external dispute resolution can occur
       */
      externalDisputeUnlockTime: string;
      /**
       * ID of the API key that created this payment
       */
      requestedById: string;
      /**
       * SHA256 hash of the result submitted by the seller (hex string)
       */
      resultHash: string | null;
      /**
       * Timestamp when the next action was last changed
       */
      nextActionLastChangedAt: string;
      /**
       * Timestamp when the on-chain state or result was last changed
       */
      onChainStateOrResultLastChangedAt: string;
      /**
       * Timestamp when the next action or on-chain state or result was last changed
       */
      nextActionOrOnChainStateOrResultLastChangedAt: string;
      /**
       * SHA256 hash of the input data for the payment (hex string)
       */
      inputHash: string | null;
      /**
       * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
       */
      totalBuyerCardanoFees: number;
      /**
       * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
       */
      totalSellerCardanoFees: number;
      /**
       * Cooldown period in milliseconds for the seller to dispute
       */
      cooldownTime: number;
      /**
       * Cooldown period in milliseconds for the buyer to dispute
       */
      cooldownTimeOtherParty: number;
      /**
       * Current state of the payment on the blockchain. Null if not yet on-chain
       */
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      /**
       * Next action required for this payment
       */
      NextAction: {
        /**
         * Next action required for this payment
         */
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        /**
         * Type of error that occurred, if any
         */
        errorType: 'NetworkError' | 'Unknown';
        /**
         * Additional details about the error, if any
         */
        errorNote: string | null;
        /**
         * SHA256 hash of the result to be submitted (hex string). Null if not applicable
         */
        resultHash: string | null;
      };
      /**
       * Current active transaction for this payment. Null if no transaction in progress
       */
      CurrentTransaction: {
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Timestamp when the transaction was created
         */
        createdAt: string;
        /**
         * Timestamp when the transaction was last updated
         */
        updatedAt: string;
        fees: string | null;
        /**
         * Block height of the transaction
         */
        blockHeight: number | null;
        /**
         * Block time of the transaction
         */
        blockTime: number | null;
        /**
         * Cardano transaction hash
         */
        txHash: string | null;
        /**
         * Current status of the transaction
         */
        status:
          | 'Pending'
          | 'Confirmed'
          | 'FailedViaTimeout'
          | 'FailedViaManualReset'
          | 'RolledBack';
        /**
         * Previous on-chain state before this transaction
         */
        previousOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * New on-chain state of this transaction
         */
        newOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * Number of block confirmations for this transaction
         */
        confirmations: number | null;
      } | null;
      RequestedFunds: Array<{
        /**
         * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Use an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the seller
       */
      WithdrawnForSeller: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * List of assets and amounts withdrawn for the buyer (refunds)
       */
      WithdrawnForBuyer: Array<{
        /**
         * Amount of the asset withdrawn (as string to handle large numbers)
         */
        amount: string;
        /**
         * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
         */
        unit: string;
      }>;
      /**
       * Payment source configuration for this payment
       */
      PaymentSource: {
        /**
         * Unique identifier for the payment source
         */
        id: string;
        /**
         * The Cardano network (Mainnet, Preprod, or Preview)
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * Address of the smart contract managing this payment
         */
        smartContractAddress: string;
        /**
         * Policy ID for the agent registry NFTs. Null if not applicable
         */
        policyId: string | null;
      };
      /**
       * Buyer wallet information. Null if buyer has not yet submitted payment
       */
      BuyerWallet: {
        /**
         * Unique identifier for the buyer wallet
         */
        id: string;
        /**
         * Payment key hash of the buyer wallet
         */
        walletVkey: string;
      } | null;
      /**
       * Smart contract wallet (seller wallet) managing this payment. Null if not set
       */
      SmartContractWallet: {
        /**
         * Unique identifier for the smart contract wallet
         */
        id: string;
        /**
         * Payment key hash of the smart contract wallet
         */
        walletVkey: string;
        /**
         * Cardano address of the smart contract wallet
         */
        walletAddress: string;
      } | null;
      /**
       * Optional metadata stored with the payment for additional context. Null if not provided
       */
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentAuthorizeRefundResponse =
  PostPaymentAuthorizeRefundResponses[keyof PostPaymentAuthorizeRefundResponses];

export type PostPaymentErrorStateRecoveryData = {
  /**
   * Payment error recovery request details
   */
  body?: {
    /**
     * The blockchain identifier of the payment request
     */
    blockchainIdentifier: string;
    /**
     * The network the transaction was made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The time of the last update, to ensure you clear the correct error state
     */
    updatedAt: Date;
  };
  path?: never;
  query?: never;
  url: '/payment/error-state-recovery/';
};

export type PostPaymentErrorStateRecoveryErrors = {
  /**
   * Bad Request (not in WaitingForManualAction state, no error to clear, or invalid input)
   */
  400: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Payment request not found
   */
  404: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentErrorStateRecoveryError =
  PostPaymentErrorStateRecoveryErrors[keyof PostPaymentErrorStateRecoveryErrors];

export type PostPaymentErrorStateRecoveryResponses = {
  /**
   * Error state cleared successfully for payment request
   */
  200: {
    status: string;
    data: {
      id: string;
    };
  };
};

export type PostPaymentErrorStateRecoveryResponse =
  PostPaymentErrorStateRecoveryResponses[keyof PostPaymentErrorStateRecoveryResponses];

export type PostPurchaseErrorStateRecoveryData = {
  /**
   * Purchase error recovery request details
   */
  body?: {
    /**
     * The blockchain identifier of the purchase request
     */
    blockchainIdentifier: string;
    /**
     * The network the transaction was made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The time of the last update, to ensure you clear the correct error state
     */
    updatedAt: Date;
  };
  path?: never;
  query?: never;
  url: '/purchase/error-state-recovery/';
};

export type PostPurchaseErrorStateRecoveryErrors = {
  /**
   * Bad Request (not in WaitingForManualAction state, no error to clear, or invalid input)
   */
  400: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Purchase request not found
   */
  404: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseErrorStateRecoveryError =
  PostPurchaseErrorStateRecoveryErrors[keyof PostPurchaseErrorStateRecoveryErrors];

export type PostPurchaseErrorStateRecoveryResponses = {
  /**
   * Error state cleared successfully for purchase request
   */
  200: {
    status: string;
    data: {
      id: string;
    };
  };
};

export type PostPurchaseErrorStateRecoveryResponse =
  PostPurchaseErrorStateRecoveryResponses[keyof PostPurchaseErrorStateRecoveryResponses];

export type GetPurchaseData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Used to paginate through the purchases. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/';
};

export type GetPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseResponses = {
  /**
   * Purchase status
   */
  200: {
    status: string;
    data: {
      Purchases: Array<Purchase>;
    };
  };
};

export type GetPurchaseResponse =
  GetPurchaseResponses[keyof GetPurchaseResponses];

export type PostPurchaseData = {
  body?: {
    /**
     * The identifier of the purchase. Is provided by the seller
     */
    blockchainIdentifier: string;
    /**
     * The network the transaction will be made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The hash of the input data of the purchase, should be sha256 hash of the input data, therefore needs to be in hex string format
     */
    inputHash: string;
    /**
     * The verification key of the seller
     */
    sellerVkey: string;
    /**
     * The identifier of the agent that is being purchased
     */
    agentIdentifier: string;
    /**
     * The amounts to be paid for the purchase
     */
    Amounts?: Array<{
      /**
       * Amount of the asset in smallest unit (e.g., lovelace for ADA)
       */
      amount: string;
      /**
       * Asset policy id + asset name concatenated. Empty string for ADA/lovelace
       */
      unit: string;
    }>;
    /**
     * The time after which the purchase will be unlocked. In unix time (number)
     */
    unlockTime: string;
    /**
     * The time after which the purchase will be unlocked for external dispute. In unix time (number)
     */
    externalDisputeUnlockTime: string;
    /**
     * The time by which the result has to be submitted. In unix time (number)
     */
    submitResultTime: string;
    /**
     * The time after which the purchase has to be submitted to the smart contract
     */
    payByTime: string;
    /**
     * Metadata to be stored with the purchase request
     */
    metadata?: string;
    /**
     * The nonce of the purchaser of the purchase, needs to be in hex format
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/';
};

export type PostPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Conflict (purchase request already exists)
   */
  409: {
    status: string;
    error: {
      message: string;
    };
    id: string;
    object: Purchase;
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseError = PostPurchaseErrors[keyof PostPurchaseErrors];

export type PostPurchaseResponses = {
  /**
   * Purchase request created
   */
  200: {
    data: Purchase;
    status: string;
  };
};

export type PostPurchaseResponse =
  PostPurchaseResponses[keyof PostPurchaseResponses];

export type GetPurchaseDiffData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Pagination cursor (purchase id). Used as tie-breaker when lastUpdate equals a purchase change timestamp
     */
    cursorId?: string;
    /**
     * Return purchases whose selected status timestamp changed at/after this ISO timestamp
     */
    lastUpdate?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/diff';
};

export type GetPurchaseDiffErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseDiffResponses = {
  /**
   * Purchase diff
   */
  200: {
    status: string;
    data: {
      Purchases: Array<Purchase>;
    };
  };
};

export type GetPurchaseDiffResponse =
  GetPurchaseDiffResponses[keyof GetPurchaseDiffResponses];

export type GetPurchaseDiffNextActionData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Pagination cursor (purchase id). Used as tie-breaker when lastUpdate equals a purchase change timestamp
     */
    cursorId?: string;
    /**
     * Return purchases whose selected status timestamp changed at/after this ISO timestamp
     */
    lastUpdate?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/diff/next-action';
};

export type GetPurchaseDiffNextActionErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseDiffNextActionResponses = {
  /**
   * Purchase diff
   */
  200: {
    status: string;
    data: {
      Purchases: Array<Purchase>;
    };
  };
};

export type GetPurchaseDiffNextActionResponse =
  GetPurchaseDiffNextActionResponses[keyof GetPurchaseDiffNextActionResponses];

export type GetPurchaseDiffOnchainStateOrResultData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Pagination cursor (purchase id). Used as tie-breaker when lastUpdate equals a purchase change timestamp
     */
    cursorId?: string;
    /**
     * Return purchases whose selected status timestamp changed at/after this ISO timestamp
     */
    lastUpdate?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/diff/onchain-state-or-result';
};

export type GetPurchaseDiffOnchainStateOrResultErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseDiffOnchainStateOrResultResponses = {
  /**
   * Purchase diff
   */
  200: {
    status: string;
    data: {
      Purchases: Array<Purchase>;
    };
  };
};

export type GetPurchaseDiffOnchainStateOrResultResponse =
  GetPurchaseDiffOnchainStateOrResultResponses[keyof GetPurchaseDiffOnchainStateOrResultResponses];

export type PostPurchaseRequestRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/purchase/request-refund';
};

export type PostPurchaseRequestRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseRequestRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      /**
       * Unique identifier for the purchase
       */
      id: string;
      /**
       * Timestamp when the purchase was created
       */
      createdAt: string;
      /**
       * Timestamp when the purchase was last updated
       */
      updatedAt: string;
      /**
       * Unique blockchain identifier for the purchase
       */
      blockchainIdentifier: string;
      /**
       * Identifier of the agent that is being purchased
       */
      agentIdentifier: string | null;
      /**
       * Timestamp when the purchase was last checked on-chain. Null if never checked
       */
      lastCheckedAt: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
       */
      payByTime: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the seller must submit the result
       */
      submitResultTime: string;
      /**
       * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
       */
      unlockTime: string;
      /**
       * Unix timestamp (in milliseconds) after which external dispute resolution can occur
       */
      externalDisputeUnlockTime: string;
      /**
       * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
       */
      totalBuyerCardanoFees: number;
      /**
       * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
       */
      totalSellerCardanoFees: number;
      /**
       * Timestamp when the next action or on-chain state or result was last changed
       */
      nextActionOrOnChainStateOrResultLastChangedAt: string;
      /**
       * Timestamp when the next action was last changed
       */
      nextActionLastChangedAt: string;
      /**
       * Timestamp when the on-chain state or result was last changed
       */
      onChainStateOrResultLastChangedAt: string;
      /**
       * ID of the API key that created this purchase
       */
      requestedById: string;
      /**
       * Current state of the purchase on the blockchain. Null if not yet on-chain
       */
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      /**
       * Amount of collateral to return in lovelace. Null if no collateral
       */
      collateralReturnLovelace: string | null;
      /**
       * Cooldown period in milliseconds for the buyer to dispute
       */
      cooldownTime: number;
      /**
       * Cooldown period in milliseconds for the seller to dispute
       */
      cooldownTimeOtherParty: number;
      /**
       * SHA256 hash of the input data for the purchase (hex string)
       */
      inputHash: string;
      /**
       * SHA256 hash of the result submitted by the seller (hex string)
       */
      resultHash: string | null;
      /**
       * Next action required for this purchase
       */
      NextAction: {
        /**
         * Next action required for this purchase
         */
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        /**
         * Type of error that occurred, if any
         */
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        /**
         * Additional details about the error, if any
         */
        errorNote: string | null;
      };
      /**
       * Current active transaction for this purchase. Null if no transaction in progress
       */
      CurrentTransaction: {
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Timestamp when the transaction was created
         */
        createdAt: string;
        /**
         * Timestamp when the transaction was last updated
         */
        updatedAt: string;
        /**
         * Cardano transaction hash
         */
        txHash: string | null;
        /**
         * Current status of the transaction
         */
        status:
          | 'Pending'
          | 'Confirmed'
          | 'FailedViaTimeout'
          | 'FailedViaManualReset'
          | 'RolledBack';
        /**
         * Fees of the transaction
         */
        fees: string | null;
        /**
         * Block height of the transaction
         */
        blockHeight: number | null;
        /**
         * Block time of the transaction
         */
        blockTime: number | null;
        /**
         * Previous on-chain state before this transaction
         */
        previousOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * New on-chain state of this transaction
         */
        newOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * Number of block confirmations for this transaction
         */
        confirmations: number | null;
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
      };
      /**
       * Seller wallet information. Null if not set
       */
      SellerWallet: {
        /**
         * Unique identifier for the seller wallet
         */
        id: string;
        /**
         * Payment key hash of the seller wallet
         */
        walletVkey: string;
      } | null;
      /**
       * Smart contract wallet (seller wallet) managing this purchase. Null if not set
       */
      SmartContractWallet: {
        /**
         * Unique identifier for the smart contract wallet
         */
        id: string;
        /**
         * Payment key hash of the smart contract wallet
         */
        walletVkey: string;
        /**
         * Cardano address of the smart contract wallet
         */
        walletAddress: string;
      } | null;
      /**
       * Optional metadata stored with the purchase for additional context. Null if not provided
       */
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseRequestRefundResponse =
  PostPurchaseRequestRefundResponses[keyof PostPurchaseRequestRefundResponses];

export type PostPurchaseCancelRefundRequestData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/purchase/cancel-refund-request';
};

export type PostPurchaseCancelRefundRequestErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseCancelRefundRequestResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      /**
       * Unique identifier for the purchase
       */
      id: string;
      /**
       * Timestamp when the purchase was created
       */
      createdAt: string;
      /**
       * Timestamp when the purchase was last updated
       */
      updatedAt: string;
      /**
       * Unique blockchain identifier for the purchase
       */
      blockchainIdentifier: string;
      /**
       * Identifier of the agent that is being purchased
       */
      agentIdentifier: string | null;
      /**
       * Timestamp when the purchase was last checked on-chain. Null if never checked
       */
      lastCheckedAt: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the buyer must submit the payment transaction. Null if not set
       */
      payByTime: string | null;
      /**
       * Unix timestamp (in milliseconds) by which the seller must submit the result
       */
      submitResultTime: string;
      /**
       * Unix timestamp (in milliseconds) after which funds can be unlocked if no disputes
       */
      unlockTime: string;
      /**
       * Unix timestamp (in milliseconds) after which external dispute resolution can occur
       */
      externalDisputeUnlockTime: string;
      /**
       * Total Cardano transaction fees paid by the buyer in ADA (sum of all confirmed transactions initiated by buyer)
       */
      totalBuyerCardanoFees: number;
      /**
       * Total Cardano transaction fees paid by the seller in ADA (sum of all confirmed transactions initiated by seller)
       */
      totalSellerCardanoFees: number;
      /**
       * Timestamp when the next action or on-chain state or result was last changed
       */
      nextActionOrOnChainStateOrResultLastChangedAt: string;
      /**
       * Timestamp when the next action was last changed
       */
      nextActionLastChangedAt: string;
      /**
       * Timestamp when the on-chain state or result was last changed
       */
      onChainStateOrResultLastChangedAt: string;
      /**
       * ID of the API key that created this purchase
       */
      requestedById: string;
      /**
       * Current state of the purchase on the blockchain. Null if not yet on-chain
       */
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      /**
       * Amount of collateral to return in lovelace. Null if no collateral
       */
      collateralReturnLovelace: string | null;
      /**
       * Cooldown period in milliseconds for the buyer to dispute
       */
      cooldownTime: number;
      /**
       * Cooldown period in milliseconds for the seller to dispute
       */
      cooldownTimeOtherParty: number;
      /**
       * SHA256 hash of the input data for the purchase (hex string)
       */
      inputHash: string;
      /**
       * SHA256 hash of the result submitted by the seller (hex string)
       */
      resultHash: string | null;
      /**
       * Next action required for this purchase
       */
      NextAction: {
        /**
         * Next action required for this purchase
         */
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        /**
         * Type of error that occurred, if any
         */
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        /**
         * Additional details about the error, if any
         */
        errorNote: string | null;
      };
      /**
       * Current active transaction for this purchase. Null if no transaction in progress
       */
      CurrentTransaction: {
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Timestamp when the transaction was created
         */
        createdAt: string;
        /**
         * Timestamp when the transaction was last updated
         */
        updatedAt: string;
        /**
         * Cardano transaction hash
         */
        txHash: string | null;
        /**
         * Current status of the transaction
         */
        status:
          | 'Pending'
          | 'Confirmed'
          | 'FailedViaTimeout'
          | 'FailedViaManualReset'
          | 'RolledBack';
        /**
         * Fees of the transaction
         */
        fees: string | null;
        /**
         * Block height of the transaction
         */
        blockHeight: number | null;
        /**
         * Block time of the transaction
         */
        blockTime: number | null;
        /**
         * Previous on-chain state before this transaction
         */
        previousOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * New on-chain state of this transaction
         */
        newOnChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        /**
         * Number of block confirmations for this transaction
         */
        confirmations: number | null;
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
      };
      /**
       * Seller wallet information. Null if not set
       */
      SellerWallet: {
        /**
         * Unique identifier for the seller wallet
         */
        id: string;
        /**
         * Payment key hash of the seller wallet
         */
        walletVkey: string;
      } | null;
      /**
       * Smart contract wallet (seller wallet) managing this purchase. Null if not set
       */
      SmartContractWallet: {
        /**
         * Unique identifier for the smart contract wallet
         */
        id: string;
        /**
         * Payment key hash of the smart contract wallet
         */
        walletVkey: string;
        /**
         * Cardano address of the smart contract wallet
         */
        walletAddress: string;
      } | null;
      /**
       * Optional metadata stored with the purchase for additional context. Null if not provided
       */
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseCancelRefundRequestResponse =
  PostPurchaseCancelRefundRequestResponses[keyof PostPurchaseCancelRefundRequestResponses];

export type PostPaymentResolveBlockchainIdentifierData = {
  body?: {
    /**
     * The blockchain identifier to resolve
     */
    blockchainIdentifier: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  path?: never;
  query?: never;
  url: '/payment/resolve-blockchain-identifier';
};

export type PostPaymentResolveBlockchainIdentifierErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Payment request not found
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentResolveBlockchainIdentifierResponses = {
  /**
   * Payment request resolved
   */
  200: {
    status: string;
    data: Payment;
  };
};

export type PostPaymentResolveBlockchainIdentifierResponse =
  PostPaymentResolveBlockchainIdentifierResponses[keyof PostPaymentResolveBlockchainIdentifierResponses];

export type PostPurchaseResolveBlockchainIdentifierData = {
  body?: {
    /**
     * The blockchain identifier to resolve
     */
    blockchainIdentifier: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/resolve-blockchain-identifier';
};

export type PostPurchaseResolveBlockchainIdentifierErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Purchase request not found
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseResolveBlockchainIdentifierResponses = {
  /**
   * Purchase request resolved
   */
  200: {
    status: string;
    data: Purchase;
  };
};

export type PostPurchaseResolveBlockchainIdentifierResponse =
  PostPurchaseResolveBlockchainIdentifierResponses[keyof PostPurchaseResolveBlockchainIdentifierResponses];

export type GetRegistryWalletData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The payment key of the wallet to be queried
     */
    walletVKey: string;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source to which the registration belongs
     */
    smartContractAddress?: string;
  };
  url: '/registry/wallet';
};

export type GetRegistryWalletResponses = {
  /**
   * Agent metadata
   */
  200: {
    status: string;
    data: {
      /**
       * List of agent assets registered to this wallet
       */
      Assets: Array<AgentMetadata>;
    };
  };
};

export type GetRegistryWalletResponse =
  GetRegistryWalletResponses[keyof GetRegistryWalletResponses];

export type DeleteRegistryData = {
  body?: {
    /**
     * The database ID of the agent registration record to be deleted.
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/registry/';
};

export type DeleteRegistryErrors = {
  /**
   * Bad Request - Invalid state for deletion
   */
  400: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Agent Registration not found
   */
  404: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type DeleteRegistryError =
  DeleteRegistryErrors[keyof DeleteRegistryErrors];

export type DeleteRegistryResponses = {
  /**
   * Agent registration deleted successfully
   */
  200: {
    status: string;
    data: RegistryEntry;
  };
};

export type DeleteRegistryResponse =
  DeleteRegistryResponses[keyof DeleteRegistryResponses];

export type GetRegistryData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The cursor id to paginate through the results
     */
    cursorId?: string;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
  };
  url: '/registry/';
};

export type GetRegistryResponses = {
  /**
   * Agent metadata
   */
  200: {
    status: string;
    data: {
      Assets: Array<RegistryEntry>;
    };
  };
};

export type GetRegistryResponse =
  GetRegistryResponses[keyof GetRegistryResponses];

export type PostRegistryData = {
  body?: {
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The payment key of a specific wallet used for the registration
     */
    sellingWalletVkey: string;
    /**
     * List of example outputs from the agent
     */
    ExampleOutputs: Array<{
      /**
       * Name of the example output
       */
      name: string;
      /**
       * URL to the example output
       */
      url: string;
      /**
       * MIME type of the example output (e.g., image/png, text/plain)
       */
      mimeType: string;
    }>;
    /**
     * Tags used in the registry metadata
     */
    Tags: Array<string>;
    /**
     * Name of the agent
     */
    name: string;
    /**
     * Base URL of the agent, to request interactions
     */
    apiBaseUrl: string;
    /**
     * Description of the agent
     */
    description: string;
    /**
     * Provide information about the used AI model and version
     */
    Capability: {
      /**
       * Name of the AI model/capability
       */
      name: string;
      /**
       * Version of the AI model/capability
       */
      version: string;
    };
    /**
     * Pricing information for the agent
     */
    AgentPricing:
      | {
          /**
           * Pricing type for the agent
           */
          pricingType: 'Fixed';
          /**
           * Price for a default interaction
           */
          Pricing: Array<{
            /**
             * Asset policy id + asset name concatenated. Uses an empty string for ADA/lovelace e.g (1000000 lovelace = 1 ADA)
             */
            unit: string;
            /**
             * The quantity of the asset. Make sure to convert it from the underlying smallest unit (in case of decimals, multiply it by the decimal factor e.g. for 1 ADA = 10000000 lovelace)
             */
            amount: string;
          }>;
        }
      | {
          /**
           * Pricing type for the agent
           */
          pricingType: 'Free';
        };
    /**
     * Legal information about the agent
     */
    Legal?: {
      /**
       * URL to the privacy policy
       */
      privacyPolicy?: string;
      /**
       * URL to the terms of service
       */
      terms?: string;
      /**
       * Other legal information
       */
      other?: string;
    };
    /**
     * Author information about the agent
     */
    Author: {
      /**
       * Name of the agent author
       */
      name: string;
      /**
       * Contact email of the author
       */
      contactEmail?: string;
      /**
       * Other contact information for the author
       */
      contactOther?: string;
      /**
       * Organization of the author
       */
      organization?: string;
    };
  };
  path?: never;
  query?: never;
  url: '/registry/';
};

export type PostRegistryResponses = {
  /**
   * Agent registered
   */
  200: {
    status: string;
    data: RegistryEntry;
  };
};

export type PostRegistryResponse =
  PostRegistryResponses[keyof PostRegistryResponses];

export type GetRegistryDiffData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of registry entries to return
     */
    limit?: number;
    /**
     * Pagination cursor (registry request id). Used as tie-breaker when lastUpdate equals a state-change timestamp
     */
    cursorId?: string;
    /**
     * Return registry entries whose registration state changed at/after this ISO timestamp
     */
    lastUpdate?: Date;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
  };
  url: '/registry/diff';
};

export type GetRegistryDiffErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetRegistryDiffResponses = {
  /**
   * Agent metadata diff
   */
  200: {
    status: string;
    data: {
      Assets: Array<RegistryEntry>;
    };
  };
};

export type GetRegistryDiffResponse =
  GetRegistryDiffResponses[keyof GetRegistryDiffResponses];

export type PostRegistryDeregisterData = {
  body?: {
    /**
     * The identifier of the registration (asset) to be deregistered
     */
    agentIdentifier: string;
    /**
     * The network the registration was made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment contract to which the registration belongs
     */
    smartContractAddress?: string;
  };
  path?: never;
  query?: never;
  url: '/registry/deregister';
};

export type PostRegistryDeregisterResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: RegistryEntry;
  };
};

export type PostRegistryDeregisterResponse =
  PostRegistryDeregisterResponses[keyof PostRegistryDeregisterResponses];

export type GetPaymentSourceData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source/';
};

export type GetPaymentSourceResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      /**
       * List of payment sources
       */
      PaymentSources: Array<PaymentSource>;
    };
  };
};

export type GetPaymentSourceResponse =
  GetPaymentSourceResponses[keyof GetPaymentSourceResponses];

export type DeletePaymentSourceExtendedData = {
  body?: {
    /**
     * The id of the payment source to be deleted
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type DeletePaymentSourceExtendedResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: PaymentSourceExtended;
  };
};

export type DeletePaymentSourceExtendedResponse =
  DeletePaymentSourceExtendedResponses[keyof DeletePaymentSourceExtendedResponses];

export type GetPaymentSourceExtendedData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source-extended/';
};

export type GetPaymentSourceExtendedResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      /**
       * List of payment sources with extended details including RPC configuration
       */
      ExtendedPaymentSources: Array<PaymentSourceExtended>;
    };
  };
};

export type GetPaymentSourceExtendedResponse =
  GetPaymentSourceExtendedResponses[keyof GetPaymentSourceExtendedResponses];

export type PatchPaymentSourceExtendedData = {
  body?: {
    /**
     * The id of the payment source to be updated
     */
    id: string;
    PaymentSourceConfig?: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment contract
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The mnemonic of the purchasing wallets to be added
     */
    AddPurchasingWallets?: Array<{
      /**
       * 24-word mnemonic phrase for the purchasing wallet. IMPORTANT: Backup this securely
       */
      walletMnemonic: string;
      /**
       * Note about this purchasing wallet
       */
      note: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The mnemonic of the selling wallets to be added
     */
    AddSellingWallets?: Array<{
      /**
       * 24-word mnemonic phrase for the selling wallet
       */
      walletMnemonic: string;
      /**
       * Note about this selling wallet
       */
      note: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The ids of the purchasing wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemovePurchasingWallets?: Array<{
      /**
       * ID of the purchasing wallet to remove
       */
      id: string;
    }>;
    /**
     * The ids of the selling wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemoveSellingWallets?: Array<{
      /**
       * ID of the selling wallet to remove
       */
      id: string;
    }>;
    /**
     * The latest identifier of the payment source. Usually should not be changed
     */
    lastIdentifierChecked?: string | null;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type PatchPaymentSourceExtendedResponses = {
  /**
   * Payment contract updated
   */
  200: {
    status: string;
    data: PaymentSourceExtended;
  };
};

export type PatchPaymentSourceExtendedResponse =
  PatchPaymentSourceExtendedResponses[keyof PatchPaymentSourceExtendedResponses];

export type PostPaymentSourceExtendedData = {
  body?: {
    /**
     * The network the payment source will be used on
     */
    network: 'Preprod' | 'Mainnet';
    PaymentSourceConfig: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment source
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The fee in permille to be used for the payment source. The default contract uses 50 (5%)
     */
    feeRatePermille: number | null;
    /**
     * The cooldown time in milliseconds to be used for the payment source. The default contract uses 1000 * 60 * 7 (7 minutes)
     */
    cooldownTime?: number | null;
    /**
     * The wallet addresses of the admin wallets (exactly 3)
     */
    AdminWallets: [
      {
        /**
         * Cardano address of the admin wallet
         */
        walletAddress: string;
      },
      {
        /**
         * Cardano address of the admin wallet
         */
        walletAddress: string;
      },
      {
        /**
         * Cardano address of the admin wallet
         */
        walletAddress: string;
      },
    ];
    /**
     * The wallet address of the network fee receiver wallet
     */
    FeeReceiverNetworkWallet: {
      /**
       * Cardano address that receives network fees
       */
      walletAddress: string;
    };
    /**
     * The mnemonic of the purchasing wallets to be added. Please backup the mnemonic of the wallets.
     */
    PurchasingWallets: Array<{
      /**
       * 24-word mnemonic phrase for the purchasing wallet. IMPORTANT: Backup this securely
       */
      walletMnemonic: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
      /**
       * Note about this purchasing wallet
       */
      note: string;
    }>;
    /**
     * The mnemonic of the selling wallets to be added. Please backup the mnemonic of the wallets.
     */
    SellingWallets: Array<{
      /**
       * 24-word mnemonic phrase for the selling wallet
       */
      walletMnemonic: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
      /**
       * Note about this selling wallet
       */
      note: string;
    }>;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type PostPaymentSourceExtendedResponses = {
  /**
   * Payment source created
   */
  200: {
    status: string;
    data: PaymentSourceExtended;
  };
};

export type PostPaymentSourceExtendedResponse =
  PostPaymentSourceExtendedResponses[keyof PostPaymentSourceExtendedResponses];

export type GetUtxosData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The address to get the UTXOs for
     */
    address: string;
    /**
     * The Cardano network
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The number of UTXOs to get
     */
    count?: number;
    /**
     * The page number to get
     */
    page?: number;
    /**
     * The order to get the UTXOs in
     */
    order?: 'asc' | 'desc';
  };
  url: '/utxos/';
};

export type GetUtxosResponses = {
  /**
   * UTXOs
   */
  200: {
    status: string;
    data: {
      /**
       * List of UTXOs for the specified address
       */
      Utxos: Array<Utxo>;
    };
  };
};

export type GetUtxosResponse = GetUtxosResponses[keyof GetUtxosResponses];

export type GetRpcApiKeysData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Used to paginate through the rpc provider keys
     */
    cursorId?: string;
    /**
     * The number of rpc provider keys to return
     */
    limit?: number;
  };
  url: '/rpc-api-keys/';
};

export type GetRpcApiKeysResponses = {
  /**
   * Blockfrost keys
   */
  200: {
    /**
     * List of RPC provider keys
     */
    RpcProviderKeys: Array<RpcProviderKey>;
  };
};

export type GetRpcApiKeysResponse =
  GetRpcApiKeysResponses[keyof GetRpcApiKeysResponses];

export type GetPurchaseEarningsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The unique identifier of the agent to get purchase earnings for
     */
    agentIdentifier: string;
    /**
     * Start date for earnings calculation (date format: 2024-01-01). If null, uses earliest available data
     */
    startDate?: Date | null;
    /**
     * End date for earnings calculation (date format: 2024-01-31). If null, uses current date
     */
    endDate?: Date | null;
    /**
     * The Cardano network to query earnings from
     */
    network: 'Preprod' | 'Mainnet';
  };
  url: '/purchase/earnings';
};

export type GetPurchaseEarningsErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Agent not found or no earnings data available
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseEarningsResponses = {
  /**
   * Agent purchase earnings analytics
   */
  200: {
    status: string;
    data: {
      agentIdentifier: string;
      /**
       * Actual date range used for calculation
       */
      dateRange: string;
      periodStart: string;
      periodEnd: string;
      totalTransactions: number;
      totalEarnings: Array<{
        unit: string;
        amount: string;
      }>;
      totalFeesPaid: Array<{
        unit: string;
        amount: string;
      }>;
      totalRevenue: Array<{
        unit: string;
        amount: string;
      }>;
      monthlyBreakdown: Array<{
        month: string;
        monthNumber: number;
        year: number;
        earnings: Array<{
          unit: string;
          amount: string;
        }>;
        transactions: number;
      }>;
      dailyEarnings: Array<{
        date: string;
        earnings: Array<{
          unit: string;
          amount: string;
        }>;
        revenue: Array<{
          unit: string;
          amount: string;
        }>;
        fees: Array<{
          unit: string;
          amount: string;
        }>;
        transactions: number;
      }>;
    };
  };
};

export type GetPurchaseEarningsResponse =
  GetPurchaseEarningsResponses[keyof GetPurchaseEarningsResponses];

export type GetPaymentEarningsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The unique identifier of the agent to get payment earnings for
     */
    agentIdentifier: string;
    /**
     * Start date for earnings calculation (date format: 2024-01-01). If null, uses earliest available data
     */
    startDate?: Date | null;
    /**
     * End date for earnings calculation (date format: 2024-01-31). If null, uses current date
     */
    endDate?: Date | null;
    /**
     * The Cardano network to query earnings from
     */
    network: 'Preprod' | 'Mainnet';
  };
  url: '/payment/earnings';
};

export type GetPaymentEarningsErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Agent not found or no earnings data available
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentEarningsResponses = {
  /**
   * Agent payment earnings analytics
   */
  200: {
    status: string;
    data: {
      agentIdentifier: string;
      /**
       * Actual date range used for calculation
       */
      dateRange: string;
      periodStart: string;
      periodEnd: string;
      totalTransactions: number;
      totalEarnings: Array<{
        unit: string;
        amount: string;
      }>;
      totalFeesPaid: Array<{
        unit: string;
        amount: string;
      }>;
      totalRevenue: Array<{
        unit: string;
        amount: string;
      }>;
      monthlyBreakdown: Array<{
        month: string;
        monthNumber: number;
        year: number;
        earnings: Array<{
          unit: string;
          amount: string;
        }>;
        transactions: number;
      }>;
      dailyEarnings: Array<{
        date: string;
        earnings: Array<{
          unit: string;
          amount: string;
        }>;
        revenue: Array<{
          unit: string;
          amount: string;
        }>;
        fees: Array<{
          unit: string;
          amount: string;
        }>;
        transactions: number;
      }>;
    };
  };
};

export type GetPaymentEarningsResponse =
  GetPaymentEarningsResponses[keyof GetPaymentEarningsResponses];

export type ClientOptions = {
  baseURL: `${string}://${string}` | (string & {});
};
