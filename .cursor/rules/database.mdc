---
description: Prisma ORM and PostgreSQL database patterns
globs: ["prisma/**/*", "src/repositories/**/*.ts", "src/utils/db/**/*.ts"]
alwaysApply: false
---

You are an expert in Prisma ORM, PostgreSQL, database design, and data modeling for TypeScript applications.

Key Principles

- Use Prisma ORM for all database interactions; avoid raw SQL queries.
- Define schema in `prisma/schema.prisma`; generate client after changes.
- Use migrations for all schema changes; never modify database directly.
- Handle BigInt properly for monetary values and timestamps.
- Use transactions for operations that require atomicity.

Schema Management

- The Prisma schema is located at `prisma/schema.prisma`.
- The generated client is output to `src/generated/prisma/client`; never edit manually.
- Run `pnpm run prisma:generate` after schema changes to regenerate client.
- Run `pnpm run prisma:migrate:dev --name descriptive_name` to create migrations.
- Use descriptive migration names that explain the change.

Generated Code

- Never manually edit files in `src/generated/prisma/`; they are auto-generated.
- Import types from `@/generated/prisma/client` for type safety.
- Import the Prisma client instance from `@/utils/db`.

BigInt Handling

- Use BigInt type in Prisma schema for monetary amounts, fees, and timestamps.
- Prisma returns BigInt values as JavaScript BigInt type.
- Convert BigInt to string for JSON serialization in API responses.
- Use BigInt literals (e.g., `5000000n`) or `BigInt()` constructor in code.

Query Patterns

- Use `findUnique()` for fetching single records by unique identifier.
- Use `findMany()` for fetching multiple records with filters.
- Use `create()`, `update()`, and `delete()` for mutations.
- Use `include` option to fetch related records in a single query.
- Use `select` option to fetch only needed fields for performance.

Related Data Loading

- Use `include` to eagerly load related models in queries.
- Define complex includes with nested objects for deep relations.
- Use Prisma's `GetPayload` type helper for typing queries with includes.
- Avoid N+1 queries by including related data in initial query.

Transactions

- Use `prisma.$transaction()` for operations requiring atomicity.
- Pass async function to transaction; all operations use transaction client.
- Transaction automatically rolls back on any error.
- Use transactions for multi-step operations that must succeed together.

Soft Deletes

- Many models use `deletedAt` field for soft deletes.
- Filter soft-deleted records with `where: { deletedAt: null }`.
- Set `deletedAt: new Date()` instead of deleting records.
- Consider soft-deleted records when querying; exclude them explicitly.

Row Locking

- Use `lockAndQueryPayments()` utility for concurrent processing scenarios.
- Row-level locking prevents race conditions in concurrent operations.
- Always release locks by completing transactions.

Common Commands

- `pnpm run prisma:migrate:dev` - Create and apply migration in development.
- `pnpm run prisma:migrate` - Apply pending migrations (deploy to production).
- `pnpm run prisma:generate` - Regenerate Prisma client.
- `pnpm run prisma:seed` - Seed the database with initial data.
- `npx prisma studio` - Open Prisma Studio for database browsing (not a script, run directly).
- `npx prisma migrate reset` - Reset database (destroys all data, run directly).

Performance Considerations

- Add database indexes for frequently queried fields.
- Use `select` to limit returned fields when full records aren't needed.
- Use pagination for large result sets.
- Monitor query performance and optimize slow queries.

Refer to `prisma/schema.prisma` for the complete data model and relationships.
