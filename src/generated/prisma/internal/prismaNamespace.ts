
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  ApiKey: 'ApiKey',
  UnitValue: 'UnitValue',
  HotWallet: 'HotWallet',
  Transaction: 'Transaction',
  WalletSecret: 'WalletSecret',
  WalletBase: 'WalletBase',
  RegistryRequest: 'RegistryRequest',
  ExampleOutput: 'ExampleOutput',
  AgentPricing: 'AgentPricing',
  AgentFixedPricing: 'AgentFixedPricing',
  PaymentRequest: 'PaymentRequest',
  PaymentActionData: 'PaymentActionData',
  PurchaseRequest: 'PurchaseRequest',
  PurchaseActionData: 'PurchaseActionData',
  PaymentSourceIdentifiers: 'PaymentSourceIdentifiers',
  PaymentSource: 'PaymentSource',
  AdminWallet: 'AdminWallet',
  PaymentSourceConfig: 'PaymentSourceConfig',
  WalletMonitorConfig: 'WalletMonitorConfig',
  WalletThreshold: 'WalletThreshold',
  AssetThreshold: 'AssetThreshold',
  WebhookEndpoint: 'WebhookEndpoint',
  WebhookDelivery: 'WebhookDelivery'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "apiKey" | "unitValue" | "hotWallet" | "transaction" | "walletSecret" | "walletBase" | "registryRequest" | "exampleOutput" | "agentPricing" | "agentFixedPricing" | "paymentRequest" | "paymentActionData" | "purchaseRequest" | "purchaseActionData" | "paymentSourceIdentifiers" | "paymentSource" | "adminWallet" | "paymentSourceConfig" | "walletMonitorConfig" | "walletThreshold" | "assetThreshold" | "webhookEndpoint" | "webhookDelivery"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    ApiKey: {
      payload: Prisma.$ApiKeyPayload<ExtArgs>
      fields: Prisma.ApiKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findFirst: {
          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findMany: {
          args: Prisma.ApiKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        create: {
          args: Prisma.ApiKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        createMany: {
          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        delete: {
          args: Prisma.ApiKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        update: {
          args: Prisma.ApiKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        deleteMany: {
          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        upsert: {
          args: Prisma.ApiKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        aggregate: {
          args: Prisma.ApiKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>
        }
        groupBy: {
          args: Prisma.ApiKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApiKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number
        }
      }
    }
    UnitValue: {
      payload: Prisma.$UnitValuePayload<ExtArgs>
      fields: Prisma.UnitValueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnitValueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnitValueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        findFirst: {
          args: Prisma.UnitValueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnitValueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        findMany: {
          args: Prisma.UnitValueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>[]
        }
        create: {
          args: Prisma.UnitValueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        createMany: {
          args: Prisma.UnitValueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UnitValueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>[]
        }
        delete: {
          args: Prisma.UnitValueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        update: {
          args: Prisma.UnitValueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        deleteMany: {
          args: Prisma.UnitValueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnitValueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UnitValueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>[]
        }
        upsert: {
          args: Prisma.UnitValueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitValuePayload>
        }
        aggregate: {
          args: Prisma.UnitValueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnitValue>
        }
        groupBy: {
          args: Prisma.UnitValueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitValueGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnitValueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitValueCountAggregateOutputType> | number
        }
      }
    }
    HotWallet: {
      payload: Prisma.$HotWalletPayload<ExtArgs>
      fields: Prisma.HotWalletFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HotWalletFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HotWalletFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        findFirst: {
          args: Prisma.HotWalletFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HotWalletFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        findMany: {
          args: Prisma.HotWalletFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>[]
        }
        create: {
          args: Prisma.HotWalletCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        createMany: {
          args: Prisma.HotWalletCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HotWalletCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>[]
        }
        delete: {
          args: Prisma.HotWalletDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        update: {
          args: Prisma.HotWalletUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        deleteMany: {
          args: Prisma.HotWalletDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HotWalletUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HotWalletUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>[]
        }
        upsert: {
          args: Prisma.HotWalletUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HotWalletPayload>
        }
        aggregate: {
          args: Prisma.HotWalletAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHotWallet>
        }
        groupBy: {
          args: Prisma.HotWalletGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HotWalletGroupByOutputType>[]
        }
        count: {
          args: Prisma.HotWalletCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HotWalletCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    WalletSecret: {
      payload: Prisma.$WalletSecretPayload<ExtArgs>
      fields: Prisma.WalletSecretFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletSecretFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletSecretFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        findFirst: {
          args: Prisma.WalletSecretFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletSecretFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        findMany: {
          args: Prisma.WalletSecretFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>[]
        }
        create: {
          args: Prisma.WalletSecretCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        createMany: {
          args: Prisma.WalletSecretCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletSecretCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>[]
        }
        delete: {
          args: Prisma.WalletSecretDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        update: {
          args: Prisma.WalletSecretUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        deleteMany: {
          args: Prisma.WalletSecretDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletSecretUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletSecretUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>[]
        }
        upsert: {
          args: Prisma.WalletSecretUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletSecretPayload>
        }
        aggregate: {
          args: Prisma.WalletSecretAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletSecret>
        }
        groupBy: {
          args: Prisma.WalletSecretGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletSecretGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletSecretCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletSecretCountAggregateOutputType> | number
        }
      }
    }
    WalletBase: {
      payload: Prisma.$WalletBasePayload<ExtArgs>
      fields: Prisma.WalletBaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletBaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletBaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        findFirst: {
          args: Prisma.WalletBaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletBaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        findMany: {
          args: Prisma.WalletBaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>[]
        }
        create: {
          args: Prisma.WalletBaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        createMany: {
          args: Prisma.WalletBaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletBaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>[]
        }
        delete: {
          args: Prisma.WalletBaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        update: {
          args: Prisma.WalletBaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        deleteMany: {
          args: Prisma.WalletBaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletBaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletBaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>[]
        }
        upsert: {
          args: Prisma.WalletBaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletBasePayload>
        }
        aggregate: {
          args: Prisma.WalletBaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletBase>
        }
        groupBy: {
          args: Prisma.WalletBaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletBaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletBaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletBaseCountAggregateOutputType> | number
        }
      }
    }
    RegistryRequest: {
      payload: Prisma.$RegistryRequestPayload<ExtArgs>
      fields: Prisma.RegistryRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RegistryRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RegistryRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        findFirst: {
          args: Prisma.RegistryRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RegistryRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        findMany: {
          args: Prisma.RegistryRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>[]
        }
        create: {
          args: Prisma.RegistryRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        createMany: {
          args: Prisma.RegistryRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RegistryRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>[]
        }
        delete: {
          args: Prisma.RegistryRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        update: {
          args: Prisma.RegistryRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        deleteMany: {
          args: Prisma.RegistryRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RegistryRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RegistryRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>[]
        }
        upsert: {
          args: Prisma.RegistryRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegistryRequestPayload>
        }
        aggregate: {
          args: Prisma.RegistryRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRegistryRequest>
        }
        groupBy: {
          args: Prisma.RegistryRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegistryRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.RegistryRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegistryRequestCountAggregateOutputType> | number
        }
      }
    }
    ExampleOutput: {
      payload: Prisma.$ExampleOutputPayload<ExtArgs>
      fields: Prisma.ExampleOutputFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExampleOutputFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExampleOutputFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        findFirst: {
          args: Prisma.ExampleOutputFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExampleOutputFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        findMany: {
          args: Prisma.ExampleOutputFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>[]
        }
        create: {
          args: Prisma.ExampleOutputCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        createMany: {
          args: Prisma.ExampleOutputCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExampleOutputCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>[]
        }
        delete: {
          args: Prisma.ExampleOutputDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        update: {
          args: Prisma.ExampleOutputUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        deleteMany: {
          args: Prisma.ExampleOutputDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExampleOutputUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExampleOutputUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>[]
        }
        upsert: {
          args: Prisma.ExampleOutputUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExampleOutputPayload>
        }
        aggregate: {
          args: Prisma.ExampleOutputAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExampleOutput>
        }
        groupBy: {
          args: Prisma.ExampleOutputGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExampleOutputGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExampleOutputCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExampleOutputCountAggregateOutputType> | number
        }
      }
    }
    AgentPricing: {
      payload: Prisma.$AgentPricingPayload<ExtArgs>
      fields: Prisma.AgentPricingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AgentPricingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AgentPricingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        findFirst: {
          args: Prisma.AgentPricingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AgentPricingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        findMany: {
          args: Prisma.AgentPricingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>[]
        }
        create: {
          args: Prisma.AgentPricingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        createMany: {
          args: Prisma.AgentPricingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AgentPricingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>[]
        }
        delete: {
          args: Prisma.AgentPricingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        update: {
          args: Prisma.AgentPricingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        deleteMany: {
          args: Prisma.AgentPricingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AgentPricingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AgentPricingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>[]
        }
        upsert: {
          args: Prisma.AgentPricingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPricingPayload>
        }
        aggregate: {
          args: Prisma.AgentPricingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgentPricing>
        }
        groupBy: {
          args: Prisma.AgentPricingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentPricingGroupByOutputType>[]
        }
        count: {
          args: Prisma.AgentPricingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentPricingCountAggregateOutputType> | number
        }
      }
    }
    AgentFixedPricing: {
      payload: Prisma.$AgentFixedPricingPayload<ExtArgs>
      fields: Prisma.AgentFixedPricingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AgentFixedPricingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AgentFixedPricingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        findFirst: {
          args: Prisma.AgentFixedPricingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AgentFixedPricingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        findMany: {
          args: Prisma.AgentFixedPricingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>[]
        }
        create: {
          args: Prisma.AgentFixedPricingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        createMany: {
          args: Prisma.AgentFixedPricingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AgentFixedPricingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>[]
        }
        delete: {
          args: Prisma.AgentFixedPricingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        update: {
          args: Prisma.AgentFixedPricingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        deleteMany: {
          args: Prisma.AgentFixedPricingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AgentFixedPricingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AgentFixedPricingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>[]
        }
        upsert: {
          args: Prisma.AgentFixedPricingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentFixedPricingPayload>
        }
        aggregate: {
          args: Prisma.AgentFixedPricingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgentFixedPricing>
        }
        groupBy: {
          args: Prisma.AgentFixedPricingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentFixedPricingGroupByOutputType>[]
        }
        count: {
          args: Prisma.AgentFixedPricingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgentFixedPricingCountAggregateOutputType> | number
        }
      }
    }
    PaymentRequest: {
      payload: Prisma.$PaymentRequestPayload<ExtArgs>
      fields: Prisma.PaymentRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        findFirst: {
          args: Prisma.PaymentRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        findMany: {
          args: Prisma.PaymentRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
        }
        create: {
          args: Prisma.PaymentRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        createMany: {
          args: Prisma.PaymentRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
        }
        delete: {
          args: Prisma.PaymentRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        update: {
          args: Prisma.PaymentRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        deleteMany: {
          args: Prisma.PaymentRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
        }
        upsert: {
          args: Prisma.PaymentRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
        }
        aggregate: {
          args: Prisma.PaymentRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentRequest>
        }
        groupBy: {
          args: Prisma.PaymentRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentRequestCountAggregateOutputType> | number
        }
      }
    }
    PaymentActionData: {
      payload: Prisma.$PaymentActionDataPayload<ExtArgs>
      fields: Prisma.PaymentActionDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentActionDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentActionDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        findFirst: {
          args: Prisma.PaymentActionDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentActionDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        findMany: {
          args: Prisma.PaymentActionDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>[]
        }
        create: {
          args: Prisma.PaymentActionDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        createMany: {
          args: Prisma.PaymentActionDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentActionDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>[]
        }
        delete: {
          args: Prisma.PaymentActionDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        update: {
          args: Prisma.PaymentActionDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        deleteMany: {
          args: Prisma.PaymentActionDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentActionDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentActionDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>[]
        }
        upsert: {
          args: Prisma.PaymentActionDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentActionDataPayload>
        }
        aggregate: {
          args: Prisma.PaymentActionDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentActionData>
        }
        groupBy: {
          args: Prisma.PaymentActionDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentActionDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentActionDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentActionDataCountAggregateOutputType> | number
        }
      }
    }
    PurchaseRequest: {
      payload: Prisma.$PurchaseRequestPayload<ExtArgs>
      fields: Prisma.PurchaseRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        findFirst: {
          args: Prisma.PurchaseRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        findMany: {
          args: Prisma.PurchaseRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
        }
        create: {
          args: Prisma.PurchaseRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        createMany: {
          args: Prisma.PurchaseRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
        }
        delete: {
          args: Prisma.PurchaseRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        update: {
          args: Prisma.PurchaseRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
        }
        aggregate: {
          args: Prisma.PurchaseRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseRequest>
        }
        groupBy: {
          args: Prisma.PurchaseRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseRequestCountAggregateOutputType> | number
        }
      }
    }
    PurchaseActionData: {
      payload: Prisma.$PurchaseActionDataPayload<ExtArgs>
      fields: Prisma.PurchaseActionDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseActionDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseActionDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        findFirst: {
          args: Prisma.PurchaseActionDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseActionDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        findMany: {
          args: Prisma.PurchaseActionDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>[]
        }
        create: {
          args: Prisma.PurchaseActionDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        createMany: {
          args: Prisma.PurchaseActionDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseActionDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>[]
        }
        delete: {
          args: Prisma.PurchaseActionDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        update: {
          args: Prisma.PurchaseActionDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseActionDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseActionDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseActionDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseActionDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseActionDataPayload>
        }
        aggregate: {
          args: Prisma.PurchaseActionDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseActionData>
        }
        groupBy: {
          args: Prisma.PurchaseActionDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseActionDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseActionDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseActionDataCountAggregateOutputType> | number
        }
      }
    }
    PaymentSourceIdentifiers: {
      payload: Prisma.$PaymentSourceIdentifiersPayload<ExtArgs>
      fields: Prisma.PaymentSourceIdentifiersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentSourceIdentifiersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentSourceIdentifiersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        findFirst: {
          args: Prisma.PaymentSourceIdentifiersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentSourceIdentifiersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        findMany: {
          args: Prisma.PaymentSourceIdentifiersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>[]
        }
        create: {
          args: Prisma.PaymentSourceIdentifiersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        createMany: {
          args: Prisma.PaymentSourceIdentifiersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentSourceIdentifiersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>[]
        }
        delete: {
          args: Prisma.PaymentSourceIdentifiersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        update: {
          args: Prisma.PaymentSourceIdentifiersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        deleteMany: {
          args: Prisma.PaymentSourceIdentifiersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentSourceIdentifiersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentSourceIdentifiersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>[]
        }
        upsert: {
          args: Prisma.PaymentSourceIdentifiersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceIdentifiersPayload>
        }
        aggregate: {
          args: Prisma.PaymentSourceIdentifiersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentSourceIdentifiers>
        }
        groupBy: {
          args: Prisma.PaymentSourceIdentifiersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceIdentifiersGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentSourceIdentifiersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceIdentifiersCountAggregateOutputType> | number
        }
      }
    }
    PaymentSource: {
      payload: Prisma.$PaymentSourcePayload<ExtArgs>
      fields: Prisma.PaymentSourceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentSourceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentSourceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        findFirst: {
          args: Prisma.PaymentSourceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentSourceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        findMany: {
          args: Prisma.PaymentSourceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>[]
        }
        create: {
          args: Prisma.PaymentSourceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        createMany: {
          args: Prisma.PaymentSourceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentSourceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>[]
        }
        delete: {
          args: Prisma.PaymentSourceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        update: {
          args: Prisma.PaymentSourceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        deleteMany: {
          args: Prisma.PaymentSourceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentSourceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentSourceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>[]
        }
        upsert: {
          args: Prisma.PaymentSourceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourcePayload>
        }
        aggregate: {
          args: Prisma.PaymentSourceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentSource>
        }
        groupBy: {
          args: Prisma.PaymentSourceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentSourceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceCountAggregateOutputType> | number
        }
      }
    }
    AdminWallet: {
      payload: Prisma.$AdminWalletPayload<ExtArgs>
      fields: Prisma.AdminWalletFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdminWalletFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdminWalletFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        findFirst: {
          args: Prisma.AdminWalletFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdminWalletFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        findMany: {
          args: Prisma.AdminWalletFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
        }
        create: {
          args: Prisma.AdminWalletCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        createMany: {
          args: Prisma.AdminWalletCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdminWalletCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
        }
        delete: {
          args: Prisma.AdminWalletDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        update: {
          args: Prisma.AdminWalletUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        deleteMany: {
          args: Prisma.AdminWalletDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdminWalletUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdminWalletUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
        }
        upsert: {
          args: Prisma.AdminWalletUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminWalletPayload>
        }
        aggregate: {
          args: Prisma.AdminWalletAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdminWallet>
        }
        groupBy: {
          args: Prisma.AdminWalletGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminWalletGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdminWalletCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminWalletCountAggregateOutputType> | number
        }
      }
    }
    PaymentSourceConfig: {
      payload: Prisma.$PaymentSourceConfigPayload<ExtArgs>
      fields: Prisma.PaymentSourceConfigFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentSourceConfigFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentSourceConfigFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        findFirst: {
          args: Prisma.PaymentSourceConfigFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentSourceConfigFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        findMany: {
          args: Prisma.PaymentSourceConfigFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>[]
        }
        create: {
          args: Prisma.PaymentSourceConfigCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        createMany: {
          args: Prisma.PaymentSourceConfigCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentSourceConfigCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>[]
        }
        delete: {
          args: Prisma.PaymentSourceConfigDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        update: {
          args: Prisma.PaymentSourceConfigUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        deleteMany: {
          args: Prisma.PaymentSourceConfigDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentSourceConfigUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentSourceConfigUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>[]
        }
        upsert: {
          args: Prisma.PaymentSourceConfigUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentSourceConfigPayload>
        }
        aggregate: {
          args: Prisma.PaymentSourceConfigAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentSourceConfig>
        }
        groupBy: {
          args: Prisma.PaymentSourceConfigGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceConfigGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentSourceConfigCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentSourceConfigCountAggregateOutputType> | number
        }
      }
    }
    WalletMonitorConfig: {
      payload: Prisma.$WalletMonitorConfigPayload<ExtArgs>
      fields: Prisma.WalletMonitorConfigFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletMonitorConfigFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletMonitorConfigFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        findFirst: {
          args: Prisma.WalletMonitorConfigFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletMonitorConfigFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        findMany: {
          args: Prisma.WalletMonitorConfigFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>[]
        }
        create: {
          args: Prisma.WalletMonitorConfigCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        createMany: {
          args: Prisma.WalletMonitorConfigCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletMonitorConfigCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>[]
        }
        delete: {
          args: Prisma.WalletMonitorConfigDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        update: {
          args: Prisma.WalletMonitorConfigUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        deleteMany: {
          args: Prisma.WalletMonitorConfigDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletMonitorConfigUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletMonitorConfigUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>[]
        }
        upsert: {
          args: Prisma.WalletMonitorConfigUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletMonitorConfigPayload>
        }
        aggregate: {
          args: Prisma.WalletMonitorConfigAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletMonitorConfig>
        }
        groupBy: {
          args: Prisma.WalletMonitorConfigGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletMonitorConfigGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletMonitorConfigCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletMonitorConfigCountAggregateOutputType> | number
        }
      }
    }
    WalletThreshold: {
      payload: Prisma.$WalletThresholdPayload<ExtArgs>
      fields: Prisma.WalletThresholdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletThresholdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletThresholdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        findFirst: {
          args: Prisma.WalletThresholdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletThresholdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        findMany: {
          args: Prisma.WalletThresholdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>[]
        }
        create: {
          args: Prisma.WalletThresholdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        createMany: {
          args: Prisma.WalletThresholdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletThresholdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>[]
        }
        delete: {
          args: Prisma.WalletThresholdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        update: {
          args: Prisma.WalletThresholdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        deleteMany: {
          args: Prisma.WalletThresholdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletThresholdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletThresholdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>[]
        }
        upsert: {
          args: Prisma.WalletThresholdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletThresholdPayload>
        }
        aggregate: {
          args: Prisma.WalletThresholdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletThreshold>
        }
        groupBy: {
          args: Prisma.WalletThresholdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletThresholdGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletThresholdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletThresholdCountAggregateOutputType> | number
        }
      }
    }
    AssetThreshold: {
      payload: Prisma.$AssetThresholdPayload<ExtArgs>
      fields: Prisma.AssetThresholdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetThresholdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetThresholdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        findFirst: {
          args: Prisma.AssetThresholdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetThresholdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        findMany: {
          args: Prisma.AssetThresholdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>[]
        }
        create: {
          args: Prisma.AssetThresholdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        createMany: {
          args: Prisma.AssetThresholdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetThresholdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>[]
        }
        delete: {
          args: Prisma.AssetThresholdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        update: {
          args: Prisma.AssetThresholdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        deleteMany: {
          args: Prisma.AssetThresholdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetThresholdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetThresholdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>[]
        }
        upsert: {
          args: Prisma.AssetThresholdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetThresholdPayload>
        }
        aggregate: {
          args: Prisma.AssetThresholdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetThreshold>
        }
        groupBy: {
          args: Prisma.AssetThresholdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetThresholdGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetThresholdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetThresholdCountAggregateOutputType> | number
        }
      }
    }
    WebhookEndpoint: {
      payload: Prisma.$WebhookEndpointPayload<ExtArgs>
      fields: Prisma.WebhookEndpointFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookEndpointFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookEndpointFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        findFirst: {
          args: Prisma.WebhookEndpointFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookEndpointFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        findMany: {
          args: Prisma.WebhookEndpointFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
        }
        create: {
          args: Prisma.WebhookEndpointCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        createMany: {
          args: Prisma.WebhookEndpointCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookEndpointCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
        }
        delete: {
          args: Prisma.WebhookEndpointDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        update: {
          args: Prisma.WebhookEndpointUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        deleteMany: {
          args: Prisma.WebhookEndpointDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookEndpointUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookEndpointUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
        }
        upsert: {
          args: Prisma.WebhookEndpointUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
        }
        aggregate: {
          args: Prisma.WebhookEndpointAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhookEndpoint>
        }
        groupBy: {
          args: Prisma.WebhookEndpointGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookEndpointGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookEndpointCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookEndpointCountAggregateOutputType> | number
        }
      }
    }
    WebhookDelivery: {
      payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
      fields: Prisma.WebhookDeliveryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        findFirst: {
          args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        findMany: {
          args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        create: {
          args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        createMany: {
          args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        delete: {
          args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        update: {
          args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        deleteMany: {
          args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
        }
        upsert: {
          args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
        }
        aggregate: {
          args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhookDelivery>
        }
        groupBy: {
          args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookDeliveryGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookDeliveryCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ApiKeyScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  token: 'token',
  tokenHash: 'tokenHash',
  status: 'status',
  permission: 'permission',
  networkLimit: 'networkLimit',
  usageLimited: 'usageLimited',
  deletedAt: 'deletedAt'
} as const

export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


export const UnitValueScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  unit: 'unit',
  amount: 'amount',
  apiKeyId: 'apiKeyId',
  agentFixedPricingId: 'agentFixedPricingId',
  paymentRequestId: 'paymentRequestId',
  purchaseRequestId: 'purchaseRequestId',
  buyerWithdrawnPaymentRequestId: 'buyerWithdrawnPaymentRequestId',
  buyerWithdrawnPurchaseRequestId: 'buyerWithdrawnPurchaseRequestId',
  sellerWithdrawnPaymentRequestId: 'sellerWithdrawnPaymentRequestId',
  sellerWithdrawnPurchaseRequestId: 'sellerWithdrawnPurchaseRequestId'
} as const

export type UnitValueScalarFieldEnum = (typeof UnitValueScalarFieldEnum)[keyof typeof UnitValueScalarFieldEnum]


export const HotWalletScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  walletVkey: 'walletVkey',
  walletAddress: 'walletAddress',
  type: 'type',
  secretId: 'secretId',
  collectionAddress: 'collectionAddress',
  pendingTransactionId: 'pendingTransactionId',
  paymentSourceId: 'paymentSourceId',
  lockedAt: 'lockedAt',
  note: 'note',
  deletedAt: 'deletedAt'
} as const

export type HotWalletScalarFieldEnum = (typeof HotWalletScalarFieldEnum)[keyof typeof HotWalletScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  txHash: 'txHash',
  status: 'status',
  confirmations: 'confirmations',
  lastCheckedAt: 'lastCheckedAt',
  fees: 'fees',
  blockHeight: 'blockHeight',
  blockTime: 'blockTime',
  outputAmount: 'outputAmount',
  utxoCount: 'utxoCount',
  withdrawalCount: 'withdrawalCount',
  assetMintOrBurnCount: 'assetMintOrBurnCount',
  redeemerCount: 'redeemerCount',
  validContract: 'validContract',
  paymentRequestHistoryId: 'paymentRequestHistoryId',
  purchaseRequestHistoryId: 'purchaseRequestHistoryId',
  previousOnChainState: 'previousOnChainState',
  newOnChainState: 'newOnChainState'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const WalletSecretScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  encryptedMnemonic: 'encryptedMnemonic'
} as const

export type WalletSecretScalarFieldEnum = (typeof WalletSecretScalarFieldEnum)[keyof typeof WalletSecretScalarFieldEnum]


export const WalletBaseScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  walletVkey: 'walletVkey',
  note: 'note',
  type: 'type',
  paymentSourceId: 'paymentSourceId',
  walletAddress: 'walletAddress'
} as const

export type WalletBaseScalarFieldEnum = (typeof WalletBaseScalarFieldEnum)[keyof typeof WalletBaseScalarFieldEnum]


export const RegistryRequestScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastCheckedAt: 'lastCheckedAt',
  paymentSourceId: 'paymentSourceId',
  smartContractWalletId: 'smartContractWalletId',
  name: 'name',
  apiBaseUrl: 'apiBaseUrl',
  capabilityName: 'capabilityName',
  capabilityVersion: 'capabilityVersion',
  description: 'description',
  privacyPolicy: 'privacyPolicy',
  terms: 'terms',
  other: 'other',
  authorName: 'authorName',
  authorContactEmail: 'authorContactEmail',
  authorContactOther: 'authorContactOther',
  authorOrganization: 'authorOrganization',
  metadataVersion: 'metadataVersion',
  tags: 'tags',
  agentPricingId: 'agentPricingId',
  agentIdentifier: 'agentIdentifier',
  state: 'state',
  registrationStateLastChangedAt: 'registrationStateLastChangedAt',
  currentTransactionId: 'currentTransactionId',
  error: 'error',
  paymentType: 'paymentType'
} as const

export type RegistryRequestScalarFieldEnum = (typeof RegistryRequestScalarFieldEnum)[keyof typeof RegistryRequestScalarFieldEnum]


export const ExampleOutputScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  mimeType: 'mimeType',
  url: 'url',
  registryRequestId: 'registryRequestId'
} as const

export type ExampleOutputScalarFieldEnum = (typeof ExampleOutputScalarFieldEnum)[keyof typeof ExampleOutputScalarFieldEnum]


export const AgentPricingScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  pricingType: 'pricingType',
  agentFixedPricingId: 'agentFixedPricingId'
} as const

export type AgentPricingScalarFieldEnum = (typeof AgentPricingScalarFieldEnum)[keyof typeof AgentPricingScalarFieldEnum]


export const AgentFixedPricingScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AgentFixedPricingScalarFieldEnum = (typeof AgentFixedPricingScalarFieldEnum)[keyof typeof AgentFixedPricingScalarFieldEnum]


export const PaymentRequestScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastCheckedAt: 'lastCheckedAt',
  paymentSourceId: 'paymentSourceId',
  smartContractWalletId: 'smartContractWalletId',
  buyerWalletId: 'buyerWalletId',
  nextActionId: 'nextActionId',
  nextActionLastChangedAt: 'nextActionLastChangedAt',
  metadata: 'metadata',
  blockchainIdentifier: 'blockchainIdentifier',
  submitResultTime: 'submitResultTime',
  unlockTime: 'unlockTime',
  externalDisputeUnlockTime: 'externalDisputeUnlockTime',
  inputHash: 'inputHash',
  resultHash: 'resultHash',
  onChainState: 'onChainState',
  onChainStateOrResultLastChangedAt: 'onChainStateOrResultLastChangedAt',
  nextActionOrOnChainStateOrResultLastChangedAt: 'nextActionOrOnChainStateOrResultLastChangedAt',
  sellerCoolDownTime: 'sellerCoolDownTime',
  buyerCoolDownTime: 'buyerCoolDownTime',
  requestedById: 'requestedById',
  currentTransactionId: 'currentTransactionId',
  collateralReturnLovelace: 'collateralReturnLovelace',
  payByTime: 'payByTime',
  totalBuyerCardanoFees: 'totalBuyerCardanoFees',
  totalSellerCardanoFees: 'totalSellerCardanoFees'
} as const

export type PaymentRequestScalarFieldEnum = (typeof PaymentRequestScalarFieldEnum)[keyof typeof PaymentRequestScalarFieldEnum]


export const PaymentActionDataScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  requestedAction: 'requestedAction',
  resultHash: 'resultHash',
  submittedTxHash: 'submittedTxHash',
  errorType: 'errorType',
  errorNote: 'errorNote',
  paymentRequestHistoryId: 'paymentRequestHistoryId'
} as const

export type PaymentActionDataScalarFieldEnum = (typeof PaymentActionDataScalarFieldEnum)[keyof typeof PaymentActionDataScalarFieldEnum]


export const PurchaseRequestScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastCheckedAt: 'lastCheckedAt',
  paymentSourceId: 'paymentSourceId',
  sellerWalletId: 'sellerWalletId',
  smartContractWalletId: 'smartContractWalletId',
  metadata: 'metadata',
  blockchainIdentifier: 'blockchainIdentifier',
  submitResultTime: 'submitResultTime',
  unlockTime: 'unlockTime',
  externalDisputeUnlockTime: 'externalDisputeUnlockTime',
  inputHash: 'inputHash',
  resultHash: 'resultHash',
  onChainState: 'onChainState',
  onChainStateOrResultLastChangedAt: 'onChainStateOrResultLastChangedAt',
  sellerCoolDownTime: 'sellerCoolDownTime',
  buyerCoolDownTime: 'buyerCoolDownTime',
  totalBuyerCardanoFees: 'totalBuyerCardanoFees',
  totalSellerCardanoFees: 'totalSellerCardanoFees',
  nextActionId: 'nextActionId',
  nextActionLastChangedAt: 'nextActionLastChangedAt',
  nextActionOrOnChainStateOrResultLastChangedAt: 'nextActionOrOnChainStateOrResultLastChangedAt',
  requestedById: 'requestedById',
  currentTransactionId: 'currentTransactionId',
  collateralReturnLovelace: 'collateralReturnLovelace',
  payByTime: 'payByTime'
} as const

export type PurchaseRequestScalarFieldEnum = (typeof PurchaseRequestScalarFieldEnum)[keyof typeof PurchaseRequestScalarFieldEnum]


export const PurchaseActionDataScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  requestedAction: 'requestedAction',
  submittedTxHash: 'submittedTxHash',
  errorType: 'errorType',
  errorNote: 'errorNote',
  purchaseRequestHistoryId: 'purchaseRequestHistoryId'
} as const

export type PurchaseActionDataScalarFieldEnum = (typeof PurchaseActionDataScalarFieldEnum)[keyof typeof PurchaseActionDataScalarFieldEnum]


export const PaymentSourceIdentifiersScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  txHash: 'txHash',
  paymentSourceId: 'paymentSourceId'
} as const

export type PaymentSourceIdentifiersScalarFieldEnum = (typeof PaymentSourceIdentifiersScalarFieldEnum)[keyof typeof PaymentSourceIdentifiersScalarFieldEnum]


export const PaymentSourceScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  network: 'network',
  lastCheckedAt: 'lastCheckedAt',
  lastIdentifierChecked: 'lastIdentifierChecked',
  syncInProgress: 'syncInProgress',
  smartContractAddress: 'smartContractAddress',
  adminWalletId: 'adminWalletId',
  feeRatePermille: 'feeRatePermille',
  cooldownTime: 'cooldownTime',
  paymentSourceConfigId: 'paymentSourceConfigId',
  deletedAt: 'deletedAt',
  policyId: 'policyId',
  disablePaymentAt: 'disablePaymentAt',
  disableSyncAt: 'disableSyncAt'
} as const

export type PaymentSourceScalarFieldEnum = (typeof PaymentSourceScalarFieldEnum)[keyof typeof PaymentSourceScalarFieldEnum]


export const AdminWalletScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  walletAddress: 'walletAddress',
  paymentSourceAdminId: 'paymentSourceAdminId',
  order: 'order'
} as const

export type AdminWalletScalarFieldEnum = (typeof AdminWalletScalarFieldEnum)[keyof typeof AdminWalletScalarFieldEnum]


export const PaymentSourceConfigScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  rpcProviderApiKey: 'rpcProviderApiKey',
  rpcProvider: 'rpcProvider'
} as const

export type PaymentSourceConfigScalarFieldEnum = (typeof PaymentSourceConfigScalarFieldEnum)[keyof typeof PaymentSourceConfigScalarFieldEnum]


export const WalletMonitorConfigScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  paymentSourceId: 'paymentSourceId',
  enabled: 'enabled',
  checkIntervalSeconds: 'checkIntervalSeconds',
  lastCheckedAt: 'lastCheckedAt',
  lastCheckStatus: 'lastCheckStatus',
  lastCheckError: 'lastCheckError'
} as const

export type WalletMonitorConfigScalarFieldEnum = (typeof WalletMonitorConfigScalarFieldEnum)[keyof typeof WalletMonitorConfigScalarFieldEnum]


export const WalletThresholdScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  hotWalletId: 'hotWalletId',
  walletMonitorConfigId: 'walletMonitorConfigId',
  enabled: 'enabled',
  adaThresholdLovelace: 'adaThresholdLovelace'
} as const

export type WalletThresholdScalarFieldEnum = (typeof WalletThresholdScalarFieldEnum)[keyof typeof WalletThresholdScalarFieldEnum]


export const AssetThresholdScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  walletThresholdId: 'walletThresholdId',
  policyId: 'policyId',
  assetName: 'assetName',
  displayName: 'displayName',
  displaySymbol: 'displaySymbol',
  decimals: 'decimals',
  minAmount: 'minAmount'
} as const

export type AssetThresholdScalarFieldEnum = (typeof AssetThresholdScalarFieldEnum)[keyof typeof AssetThresholdScalarFieldEnum]


export const WebhookEndpointScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  url: 'url',
  authToken: 'authToken',
  events: 'events',
  name: 'name',
  paymentSourceId: 'paymentSourceId',
  createdByApiKeyId: 'createdByApiKeyId',
  isActive: 'isActive',
  failureCount: 'failureCount',
  consecutiveFailures: 'consecutiveFailures',
  lastSuccessAt: 'lastSuccessAt',
  disabledAt: 'disabledAt'
} as const

export type WebhookEndpointScalarFieldEnum = (typeof WebhookEndpointScalarFieldEnum)[keyof typeof WebhookEndpointScalarFieldEnum]


export const WebhookDeliveryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  webhookEndpointId: 'webhookEndpointId',
  eventType: 'eventType',
  payload: 'payload',
  entityId: 'entityId',
  status: 'status',
  attempts: 'attempts',
  maxAttempts: 'maxAttempts',
  nextRetryAt: 'nextRetryAt',
  responseCode: 'responseCode',
  errorMessage: 'errorMessage',
  deliveredAt: 'deliveredAt',
  durationMs: 'durationMs'
} as const

export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'ApiKeyStatus'
 */
export type EnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus'>
    


/**
 * Reference to a field of type 'ApiKeyStatus[]'
 */
export type ListEnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus[]'>
    


/**
 * Reference to a field of type 'Permission'
 */
export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


/**
 * Reference to a field of type 'Permission[]'
 */
export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


/**
 * Reference to a field of type 'Network[]'
 */
export type ListEnumNetworkFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Network[]'>
    


/**
 * Reference to a field of type 'Network'
 */
export type EnumNetworkFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Network'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'HotWalletType'
 */
export type EnumHotWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotWalletType'>
    


/**
 * Reference to a field of type 'HotWalletType[]'
 */
export type ListEnumHotWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotWalletType[]'>
    


/**
 * Reference to a field of type 'TransactionStatus'
 */
export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


/**
 * Reference to a field of type 'TransactionStatus[]'
 */
export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'OnChainState'
 */
export type EnumOnChainStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnChainState'>
    


/**
 * Reference to a field of type 'OnChainState[]'
 */
export type ListEnumOnChainStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnChainState[]'>
    


/**
 * Reference to a field of type 'WalletType'
 */
export type EnumWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletType'>
    


/**
 * Reference to a field of type 'WalletType[]'
 */
export type ListEnumWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletType[]'>
    


/**
 * Reference to a field of type 'RegistrationState'
 */
export type EnumRegistrationStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationState'>
    


/**
 * Reference to a field of type 'RegistrationState[]'
 */
export type ListEnumRegistrationStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationState[]'>
    


/**
 * Reference to a field of type 'PaymentType'
 */
export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


/**
 * Reference to a field of type 'PaymentType[]'
 */
export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


/**
 * Reference to a field of type 'PricingType'
 */
export type EnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType'>
    


/**
 * Reference to a field of type 'PricingType[]'
 */
export type ListEnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType[]'>
    


/**
 * Reference to a field of type 'PaymentAction'
 */
export type EnumPaymentActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentAction'>
    


/**
 * Reference to a field of type 'PaymentAction[]'
 */
export type ListEnumPaymentActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentAction[]'>
    


/**
 * Reference to a field of type 'PaymentErrorType'
 */
export type EnumPaymentErrorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentErrorType'>
    


/**
 * Reference to a field of type 'PaymentErrorType[]'
 */
export type ListEnumPaymentErrorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentErrorType[]'>
    


/**
 * Reference to a field of type 'PurchasingAction'
 */
export type EnumPurchasingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchasingAction'>
    


/**
 * Reference to a field of type 'PurchasingAction[]'
 */
export type ListEnumPurchasingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchasingAction[]'>
    


/**
 * Reference to a field of type 'PurchaseErrorType'
 */
export type EnumPurchaseErrorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseErrorType'>
    


/**
 * Reference to a field of type 'PurchaseErrorType[]'
 */
export type ListEnumPurchaseErrorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseErrorType[]'>
    


/**
 * Reference to a field of type 'RPCProvider'
 */
export type EnumRPCProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RPCProvider'>
    


/**
 * Reference to a field of type 'RPCProvider[]'
 */
export type ListEnumRPCProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RPCProvider[]'>
    


/**
 * Reference to a field of type 'WebhookEventType[]'
 */
export type ListEnumWebhookEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventType[]'>
    


/**
 * Reference to a field of type 'WebhookEventType'
 */
export type EnumWebhookEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventType'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'WebhookDeliveryStatus'
 */
export type EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookDeliveryStatus'>
    


/**
 * Reference to a field of type 'WebhookDeliveryStatus[]'
 */
export type ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookDeliveryStatus[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  apiKey?: Prisma.ApiKeyOmit
  unitValue?: Prisma.UnitValueOmit
  hotWallet?: Prisma.HotWalletOmit
  transaction?: Prisma.TransactionOmit
  walletSecret?: Prisma.WalletSecretOmit
  walletBase?: Prisma.WalletBaseOmit
  registryRequest?: Prisma.RegistryRequestOmit
  exampleOutput?: Prisma.ExampleOutputOmit
  agentPricing?: Prisma.AgentPricingOmit
  agentFixedPricing?: Prisma.AgentFixedPricingOmit
  paymentRequest?: Prisma.PaymentRequestOmit
  paymentActionData?: Prisma.PaymentActionDataOmit
  purchaseRequest?: Prisma.PurchaseRequestOmit
  purchaseActionData?: Prisma.PurchaseActionDataOmit
  paymentSourceIdentifiers?: Prisma.PaymentSourceIdentifiersOmit
  paymentSource?: Prisma.PaymentSourceOmit
  adminWallet?: Prisma.AdminWalletOmit
  paymentSourceConfig?: Prisma.PaymentSourceConfigOmit
  walletMonitorConfig?: Prisma.WalletMonitorConfigOmit
  walletThreshold?: Prisma.WalletThresholdOmit
  assetThreshold?: Prisma.AssetThresholdOmit
  webhookEndpoint?: Prisma.WebhookEndpointOmit
  webhookDelivery?: Prisma.WebhookDeliveryOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

