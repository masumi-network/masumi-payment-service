generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model ApiKey {
  id                    String            @id @default(cuid())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  token                 String            @unique
  tokenHash             String            @unique
  status                ApiKeyStatus
  permission            Permission
  networkLimit          Network[]
  usageLimited          Boolean           @default(false)
  deletedAt             DateTime?
  PaymentRequest        PaymentRequest[]
  PurchaseRequest       PurchaseRequest[]
  RemainingUsageCredits UnitValue[]
}

model UnitValue {
  id                               String             @id @default(cuid())
  createdAt                        DateTime           @default(now())
  updatedAt                        DateTime           @updatedAt
  unit                             String
  amount                           BigInt
  apiKeyId                         String?
  agentFixedPricingId              String?
  paymentRequestId                 String?
  purchaseRequestId                String?
  buyerWithdrawnPaymentRequestId   String?
  buyerWithdrawnPurchaseRequestId  String?
  sellerWithdrawnPaymentRequestId  String?
  sellerWithdrawnPurchaseRequestId String?
  AgentFixedPricing                AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  ApiKey                           ApiKey?            @relation(fields: [apiKeyId], references: [id])
  BuyerWithdrawnPaymentRequest     PaymentRequest?    @relation("BuyerWithdrawnPaymentRequest", fields: [buyerWithdrawnPaymentRequestId], references: [id])
  BuyerWithdrawnPurchaseRequest    PurchaseRequest?   @relation("BuyerWithdrawnPurchaseRequest", fields: [buyerWithdrawnPurchaseRequestId], references: [id])
  PaymentRequest                   PaymentRequest?    @relation(fields: [paymentRequestId], references: [id])
  PurchaseRequest                  PurchaseRequest?   @relation(fields: [purchaseRequestId], references: [id])
  SellerWithdrawnPaymentRequest    PaymentRequest?    @relation("SellerWithdrawnPaymentRequest", fields: [sellerWithdrawnPaymentRequestId], references: [id])
  SellerWithdrawnPurchaseRequest   PurchaseRequest?   @relation("SellerWithdrawnPurchaseRequest", fields: [sellerWithdrawnPurchaseRequestId], references: [id])
}

model HotWallet {
  id                   String            @id @default(cuid())
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  walletVkey           String            @unique
  walletAddress        String
  type                 HotWalletType
  secretId             String
  collectionAddress    String?
  pendingTransactionId String?           @unique
  paymentSourceId      String
  lockedAt             DateTime?
  note                 String?
  deletedAt            DateTime?
  PaymentSource        PaymentSource     @relation(fields: [paymentSourceId], references: [id], onDelete: Cascade)
  PendingTransaction   Transaction?      @relation(fields: [pendingTransactionId], references: [id])
  Secret               WalletSecret      @relation(fields: [secretId], references: [id])
  PaymentRequest       PaymentRequest[]
  PurchaseRequest      PurchaseRequest[]
  RegistryRequest      RegistryRequest[]
}

model Transaction {
  id                       String            @id @default(cuid())
  createdAt                DateTime          @default(now())
  updatedAt                DateTime          @updatedAt
  txHash                   String
  status                   TransactionStatus
  lastCheckedAt            DateTime?
  paymentRequestHistoryId  String?
  purchaseRequestHistoryId String?
  BlocksWallet             HotWallet?
  PaymentRequestCurrent    PaymentRequest?   @relation("CurrentPaymentTransaction")
  PurchaseRequestCurrent   PurchaseRequest?  @relation("CurrentPurchaseTransaction")
  RegistryRequest          RegistryRequest[]
  PaymentRequestHistory    PaymentRequest?   @relation("PaymentTransactionHistory", fields: [paymentRequestHistoryId], references: [id])
  PurchaseRequestHistory   PurchaseRequest?  @relation("PurchaseTransactionHistory", fields: [purchaseRequestHistoryId], references: [id])
}

model WalletSecret {
  id                String      @id @default(cuid())
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  encryptedMnemonic String
  HotWallet         HotWallet[]
}

model WalletBase {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  walletVkey      String
  note            String?
  type            WalletType
  paymentSourceId String
  walletAddress   String            @default("")
  PaymentRequest  PaymentRequest[]
  PurchaseRequest PurchaseRequest[]
  PaymentSource   PaymentSource     @relation(fields: [paymentSourceId], references: [id])

  @@unique([paymentSourceId, walletVkey, walletAddress, type])
}

model RegistryRequest {
  id                    String            @id @default(cuid())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  lastCheckedAt         DateTime?
  paymentSourceId       String
  smartContractWalletId String
  name                  String
  apiBaseUrl            String
  capabilityName        String?
  capabilityVersion     String?
  description           String?
  privacyPolicy         String?
  terms                 String?
  other                 String?
  authorName            String
  authorContactEmail    String?
  authorContactOther    String?
  authorOrganization    String?
  metadataVersion       Int
  tags                  String[]
  agentPricingId        String            @unique
  agentIdentifier       String?           @unique
  state                 RegistrationState
  currentTransactionId  String?
  error                 String?
  paymentType           PaymentType       @default(Web3CardanoV1)
  ExampleOutputs        ExampleOutput[]
  Pricing               AgentPricing      @relation(fields: [agentPricingId], references: [id])
  CurrentTransaction    Transaction?      @relation(fields: [currentTransactionId], references: [id])
  PaymentSource         PaymentSource     @relation(fields: [paymentSourceId], references: [id])
  SmartContractWallet   HotWallet         @relation(fields: [smartContractWalletId], references: [id])
}

model ExampleOutput {
  id                String           @id @default(cuid())
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  name              String
  mimeType          String
  url               String
  registryRequestId String?
  RegistryRequest   RegistryRequest? @relation(fields: [registryRequestId], references: [id])
}

model AgentPricing {
  id                  String             @id @default(cuid())
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  pricingType         PricingType
  agentFixedPricingId String?            @unique
  FixedPricing        AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  RegistryRequest     RegistryRequest?
}

model AgentFixedPricing {
  id           String        @id @default(cuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  AgentPricing AgentPricing?
  Amounts      UnitValue[]
}

model PaymentRequest {
  id                        String            @id @default(cuid())
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  lastCheckedAt             DateTime?
  paymentSourceId           String
  smartContractWalletId     String?
  buyerWalletId             String?
  nextActionId              String            @unique
  metadata                  String?
  blockchainIdentifier      String            @unique
  submitResultTime          BigInt
  unlockTime                BigInt
  externalDisputeUnlockTime BigInt
  inputHash                 String
  resultHash                String
  onChainState              OnChainState?
  sellerCoolDownTime        BigInt
  buyerCoolDownTime         BigInt
  requestedById             String
  currentTransactionId      String?           @unique
  collateralReturnLovelace  BigInt?
  payByTime                 BigInt?
  BuyerWallet               WalletBase?       @relation(fields: [buyerWalletId], references: [id])
  CurrentTransaction        Transaction?      @relation("CurrentPaymentTransaction", fields: [currentTransactionId], references: [id])
  NextAction                PaymentActionData @relation("NextAction", fields: [nextActionId], references: [id])
  PaymentSource             PaymentSource     @relation("PaymentRequestPaymentSource", fields: [paymentSourceId], references: [id], onDelete: Cascade)
  requestedBy               ApiKey            @relation(fields: [requestedById], references: [id])
  SmartContractWallet       HotWallet?        @relation(fields: [smartContractWalletId], references: [id])
  TransactionHistory        Transaction[]     @relation("PaymentTransactionHistory")
  WithdrawnForBuyer         UnitValue[]       @relation("BuyerWithdrawnPaymentRequest")
  RequestedFunds            UnitValue[]
  WithdrawnForSeller        UnitValue[]       @relation("SellerWithdrawnPaymentRequest")
}

model PaymentActionData {
  id                    String            @id @default(cuid())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  requestedAction       PaymentAction
  resultHash            String?
  submittedTxHash       String?
  errorType             PaymentErrorType?
  errorNote             String?
  PaymentRequestCurrent PaymentRequest?   @relation("NextAction")
}

model PurchaseRequest {
  id                        String             @id @default(cuid())
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  lastCheckedAt             DateTime?
  paymentSourceId           String
  sellerWalletId            String
  smartContractWalletId     String?
  metadata                  String?
  blockchainIdentifier      String             @unique
  submitResultTime          BigInt
  unlockTime                BigInt
  externalDisputeUnlockTime BigInt
  inputHash                 String
  resultHash                String
  onChainState              OnChainState?
  sellerCoolDownTime        BigInt
  buyerCoolDownTime         BigInt
  nextActionId              String             @unique
  requestedById             String
  currentTransactionId      String?            @unique
  collateralReturnLovelace  BigInt?
  payByTime                 BigInt?
  CurrentTransaction        Transaction?       @relation("CurrentPurchaseTransaction", fields: [currentTransactionId], references: [id])
  NextAction                PurchaseActionData @relation("NextAction", fields: [nextActionId], references: [id])
  PaymentSource             PaymentSource      @relation("PurchaseRequestPaymentSource", fields: [paymentSourceId], references: [id], onDelete: Cascade)
  requestedBy               ApiKey             @relation(fields: [requestedById], references: [id])
  SellerWallet              WalletBase         @relation(fields: [sellerWalletId], references: [id], onDelete: Cascade)
  SmartContractWallet       HotWallet?         @relation(fields: [smartContractWalletId], references: [id])
  TransactionHistory        Transaction[]      @relation("PurchaseTransactionHistory")
  WithdrawnForBuyer         UnitValue[]        @relation("BuyerWithdrawnPurchaseRequest")
  PaidFunds                 UnitValue[]
  WithdrawnForSeller        UnitValue[]        @relation("SellerWithdrawnPurchaseRequest")
}

model PurchaseActionData {
  id                     String             @id @default(cuid())
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  requestedAction        PurchasingAction
  inputHash              String
  submittedTxHash        String?
  errorType              PurchaseErrorType?
  errorNote              String?
  PurchaseRequestCurrent PurchaseRequest?   @relation("NextAction")
}

model PaymentSourceIdentifiers {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  txHash          String        @unique
  paymentSourceId String
  PaymentSource   PaymentSource @relation(fields: [paymentSourceId], references: [id])
}

model PaymentSource {
  id                       String                     @id @default(cuid())
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @updatedAt
  network                  Network
  lastCheckedAt            DateTime?
  lastIdentifierChecked    String?
  syncInProgress           Boolean                    @default(false)
  smartContractAddress     String
  adminWalletId            String
  feeRatePermille          Int
  cooldownTime             Int
  paymentSourceConfigId    String                     @unique
  deletedAt                DateTime?
  policyId                 String?
  disablePaymentAt         DateTime?
  disableSyncAt            DateTime?
  AdminWallets             AdminWallet[]              @relation("AdminWallets")
  HotWallets               HotWallet[]
  PaymentRequests          PaymentRequest[]           @relation("PaymentRequestPaymentSource")
  FeeReceiverNetworkWallet AdminWallet                @relation("FeeReceiverNetworkWallet", fields: [adminWalletId], references: [id], onDelete: Cascade)
  PaymentSourceConfig      PaymentSourceConfig        @relation(fields: [paymentSourceConfigId], references: [id])
  PaymentSourceIdentifiers PaymentSourceIdentifiers[]
  PurchaseRequests         PurchaseRequest[]          @relation("PurchaseRequestPaymentSource")
  RegistryRequest          RegistryRequest[]
  WalletBases              WalletBase[]

  @@unique([network, smartContractAddress])
  @@unique([network, policyId])
}

model AdminWallet {
  id                       String          @id @default(cuid())
  createdAt                DateTime        @default(now())
  updatedAt                DateTime        @updatedAt
  walletAddress            String
  paymentSourceAdminId     String?
  order                    Int
  PaymentSourceAdmin       PaymentSource?  @relation("AdminWallets", fields: [paymentSourceAdminId], references: [id])
  PaymentSourceFeeReceiver PaymentSource[] @relation("FeeReceiverNetworkWallet")
}

model PaymentSourceConfig {
  id                String         @id @default(cuid())
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  rpcProviderApiKey String
  rpcProvider       RPCProvider
  PaymentSource     PaymentSource?
}

enum ApiKeyStatus {
  Active
  Revoked
}

enum Permission {
  Read
  ReadAndPay
  Admin
}

enum HotWalletType {
  Selling
  Purchasing
}

enum WalletType {
  Buyer
  Seller
}

enum RegistrationState {
  RegistrationRequested
  RegistrationInitiated
  RegistrationConfirmed
  RegistrationFailed
  DeregistrationRequested
  DeregistrationInitiated
  DeregistrationConfirmed
  DeregistrationFailed
}

enum PricingType {
  Fixed
  Free
}

enum PaymentErrorType {
  NetworkError
  Unknown
}

enum PurchaseErrorType {
  NetworkError
  InsufficientFunds
  Unknown
}

enum PaymentType {
  Web3CardanoV1
  None
}

enum TransactionStatus {
  Pending
  Confirmed
  FailedViaTimeout
  RolledBack
}

enum OnChainState {
  FundsLocked
  FundsOrDatumInvalid
  ResultSubmitted
  RefundRequested
  Disputed
  Withdrawn
  RefundWithdrawn
  DisputedWithdrawn
}

enum PaymentAction {
  None
  Ignore
  WaitingForManualAction
  WaitingForExternalAction
  SubmitResultRequested
  SubmitResultInitiated
  WithdrawRequested
  WithdrawInitiated
  AuthorizeRefundRequested
  AuthorizeRefundInitiated
}

enum PurchasingAction {
  None
  Ignore
  WaitingForManualAction
  WaitingForExternalAction
  FundsLockingRequested
  FundsLockingInitiated
  SetRefundRequestedRequested
  SetRefundRequestedInitiated
  UnSetRefundRequestedRequested
  UnSetRefundRequestedInitiated
  WithdrawRefundRequested
  WithdrawRefundInitiated
}

enum Network {
  Preprod
  Mainnet
}

enum RPCProvider {
  Blockfrost
}
